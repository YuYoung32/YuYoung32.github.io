<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>c&#43;&#43; on YuYoung&#39;s Blog</title>
    <link>https://yuyoung32.github.io/categories/c&#43;&#43;/</link>
    <description>Recent content in c&#43;&#43; on YuYoung&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Tue, 16 May 2023 18:04:01 +0800</lastBuildDate><atom:link href="https://yuyoung32.github.io/categories/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>C&#43;&#43;的引用与重载解析</title>
      <link>https://yuyoung32.github.io/post/c&#43;&#43;%E5%BC%95%E7%94%A8%E4%B8%8E%E9%87%8D%E8%BD%BD%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Tue, 16 May 2023 18:04:01 +0800</pubDate>
      
      <guid>https://yuyoung32.github.io/post/c&#43;&#43;%E5%BC%95%E7%94%A8%E4%B8%8E%E9%87%8D%E8%BD%BD%E8%A7%A3%E6%9E%90/</guid>
      <description>本文讲述了C++的左右值和左右值和左右值引用，以及它们在重载解析当中的顺序。
左右值和左右值引用 左右值之分 expression | \ glvalue rvalue / \ / \ lvalue xvalue prvalue 广义左值glvalue，都是可以有标识符的。广义右值rvalue，都是可移动（std::move）的。xvalue属于这两者，既可以移动又可以有标识符。
左值lvalue： 可以取地址，有名字的，非临时的就是左值。non-const左值可以放在“=”的左侧。
变量int a的a，引用int&amp;amp; a的a，数组元素int arr[]的arr[i]，左值对象的成员
返回左值引用的表达式/函数，例如，++x，x=1，函数返回值如下
#include &amp;lt;iostream&amp;gt; using namespace std; int&amp;amp; square(int&amp;amp; number) { number = number * number; // 修改参数 return number; // 返回左值引用 } int main() { int number = 5; cout &amp;lt;&amp;lt; &amp;#34;number: &amp;#34; &amp;lt;&amp;lt; number &amp;lt;&amp;lt; endl; // 输出：number: 5 square(number) = 25; // 可以在左侧赋值 cout &amp;lt;&amp;lt; &amp;#34;number: &amp;#34; &amp;lt;&amp;lt; number &amp;lt;&amp;lt; endl; // 输出：number: 25 return 0; } 特殊：字符串字面量，如&amp;quot;hello world!</description>
    </item>
    
    <item>
      <title>C&#43;&#43;动态内存分配与allocator</title>
      <link>https://yuyoung32.github.io/post/c&#43;&#43;%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E4%B8%8Eallocator/</link>
      <pubDate>Thu, 24 Nov 2022 16:52:52 +0800</pubDate>
      
      <guid>https://yuyoung32.github.io/post/c&#43;&#43;%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E4%B8%8Eallocator/</guid>
      <description>内存分配call stack 分配内存
Foo* p = new Foo(x); //等同于 Foo* p = (Foo*)operator new(sizeof(Foo)); //分配空间 此处可重载,使之不调用全局的::operator new new(p) Foo(x); //placement new 创建对象(初始化内存) //等同于 ::operator new(size_t); //等同于 malloc(size_t); 释放内存
delete p; //等同于 p-&amp;gt;~Foo();//析构函数 operator delete(p); //此处可重载,使之不调用全局的::operator delete //等同于 ::operator delete(void*); //等同于 free(void*); 重载operator new 注意：
在重载operator new，第一个参数必须是size_t形式
在重载operator delete时，第一个参数必须是void*形式
例如：
class MyClass { public: //operator new(int a)//出错，第一个参数必须是size_t void *operator new(size_t size) { cout &amp;lt;&amp;lt; &amp;#34;MyClass new&amp;#34; &amp;lt;&amp;lt; endl; return malloc(size); } void *operator new(size_t size, void* ptr) { cout &amp;lt;&amp;lt; &amp;#34;MyClass new&amp;#34; &amp;lt;&amp;lt; endl; return malloc(size); } void operator delete(void* p) { cout &amp;lt;&amp;lt; &amp;#34;MyClass delete&amp;#34; &amp;lt;&amp;lt; endl; free(p); } }; 内存池构建思路 GNU C++ pool_allocator 内存分配器 编译器在最终使用malloc时，分配的内存会在最终需求的上下有多余块，一方面是为了内存对齐，另一方面是为了调试时追踪。如下图，只有user use才是用户申请的空间。</description>
    </item>
    
    <item>
      <title>实现std::bind</title>
      <link>https://yuyoung32.github.io/post/%E5%AE%9E%E7%8E%B0stdbind/</link>
      <pubDate>Tue, 04 Oct 2022 16:05:49 +0800</pubDate>
      
      <guid>https://yuyoung32.github.io/post/%E5%AE%9E%E7%8E%B0stdbind/</guid>
      <description>手写std::bind与源码解读</description>
    </item>
    
    <item>
      <title>STL学习笔记</title>
      <link>https://yuyoung32.github.io/post/stl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 14 Sep 2022 22:55:15 +0800</pubDate>
      
      <guid>https://yuyoung32.github.io/post/stl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>前言 STL是GP编程的典范，使用容器涉及六大模块：
容器 分配器 算法 迭代器 适配器 仿函数 分配器为容器分配内存，迭代器用来访问容器数据，算法通过迭代器操作容器内的数据，算法使用仿函数改变算法过程。适配器是各部分的粘合剂。
这其中，除了算法是模板函数外，其他都是模板类。
容器 list实现 Sequence Container
有头节点的 双向 循环 链表。
deque实现 Sequence Container
deque是分段连续的。有很多个小段连续空间（buffer），外部一个数组用来存放buffer指针。通过iterator模拟连续。 外部buffer指针数组会类似vector扩容。这意味着可以不改变元素扩容，不像vector那样真正的连续。
容器适配器：stack queue stack和queue默认的Seqence是deque，stack和queue可以默认是deque的适配器。 二者还可以选用list作为底层容器。
array和vector实现 Sequence Container
vector动态连续数组，空间不足时会两倍扩充。
array，底层数组直接封装。
_Rb_tree 容器 Associative Container
如名，红黑树，节点是双向链表形式的树。模板参数提供至少前四个，分别是Key，Value（Key和Data的结合体），GetKey（仿函数，如何从Value里拿到Key），Compare（仿函数，如何比较Key）
#include &amp;lt;bits/stl_tree.h&amp;gt; int main() { struct MyS { int a; int b; }; struct GetKey { int operator()(const MyS &amp;amp;s) const { return s.a; } }; //key, key and data = value, how to get key from value, compare, allocator(default) std::_Rb_tree&amp;lt;int, MyS, GetKey, std::less&amp;lt;int&amp;gt;&amp;gt; rbTree; rbTree.</description>
    </item>
    
  </channel>
</rss>
