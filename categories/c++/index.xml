<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>c&#43;&#43; on YuYoung&#39;s Blog</title>
    <link>https://yuyoung32.github.io/categories/c&#43;&#43;/</link>
    <description>Recent content in c&#43;&#43; on YuYoung&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Thu, 24 Nov 2022 16:52:52 +0800</lastBuildDate><atom:link href="https://yuyoung32.github.io/categories/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>C&#43;&#43;动态内存分配与allocator</title>
      <link>https://yuyoung32.github.io/post/c&#43;&#43;%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E4%B8%8Eallocator/</link>
      <pubDate>Thu, 24 Nov 2022 16:52:52 +0800</pubDate>
      
      <guid>https://yuyoung32.github.io/post/c&#43;&#43;%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E4%B8%8Eallocator/</guid>
      <description>内存分配call stack 分配内存
Foo* p = new Foo(x); //等同于 Foo* p = (Foo*)operator new(sizeof(Foo)); //分配空间 此处可重载,使之不调用全局的::operator new new(p) Foo(x); //placement new 创建对象(初始化内存) //等同于 ::operator new(size_t); //等同于 malloc(size_t); 释放内存
delete p; //等同于 p-&amp;gt;~Foo();//析构函数 operator delete(p); //此处可重载,使之不调用全局的::operator delete //等同于 ::operator delete(void*); //等同于 free(void*); 重载operator new 注意：
在重载operator new，第一个参数必须是size_t形式
在重载operator delete时，第一个参数必须是void*形式
例如：
class MyClass { public: //operator new(int a)//出错，第一个参数必须是size_t void *operator new(size_t size) { cout &amp;lt;&amp;lt; &amp;#34;MyClass new&amp;#34; &amp;lt;&amp;lt; endl; return malloc(size); } void *operator new(size_t size, void* ptr) { cout &amp;lt;&amp;lt; &amp;#34;MyClass new&amp;#34; &amp;lt;&amp;lt; endl; return malloc(size); } void operator delete(void* p) { cout &amp;lt;&amp;lt; &amp;#34;MyClass delete&amp;#34; &amp;lt;&amp;lt; endl; free(p); } }; 内存池构建思路 GNU C++ pool_allocator 内存分配器 编译器在最终使用malloc时，分配的内存会在最终需求的上下有多余块，一方面是为了内存对齐，另一方面是为了调试时追踪。如下图，只有user use才是用户申请的空间。</description>
    </item>
    
    <item>
      <title>实现std::bind</title>
      <link>https://yuyoung32.github.io/post/%E5%AE%9E%E7%8E%B0stdbind/</link>
      <pubDate>Tue, 04 Oct 2022 16:05:49 +0800</pubDate>
      
      <guid>https://yuyoung32.github.io/post/%E5%AE%9E%E7%8E%B0stdbind/</guid>
      <description>手写std::bind与源码解读</description>
    </item>
    
    <item>
      <title>STL学习笔记</title>
      <link>https://yuyoung32.github.io/post/stl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 14 Sep 2022 22:55:15 +0800</pubDate>
      
      <guid>https://yuyoung32.github.io/post/stl%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>前言 STL是GP编程的典范，使用容器涉及六大模块：
容器 分配器 算法 迭代器 适配器 仿函数 分配器为容器分配内存，迭代器用来访问容器数据，算法通过迭代器操作容器内的数据，算法使用仿函数改变算法过程。适配器是各部分的粘合剂。
这其中，除了算法是模板函数外，其他都是模板类。
容器 list实现 Sequence Container
有头节点的 双向 循环 链表。
deque实现 Sequence Container
deque是分段连续的。有很多个小段连续空间（buffer），外部一个数组用来存放buffer指针。通过iterator模拟连续。 外部buffer指针数组会类似vector扩容。这意味着可以不改变元素扩容，不像vector那样真正的连续。
容器适配器：stack queue stack和queue默认的Seqence是deque，stack和queue可以默认是deque的适配器。 二者还可以选用list作为底层容器。
array和vector实现 Sequence Container
vector动态连续数组，空间不足时会两倍扩充。
array，底层数组直接封装。
_Rb_tree 容器 Associative Container
如名，红黑树，节点是双向链表形式的树。模板参数提供至少前四个，分别是Key，Value（Key和Data的结合体），GetKey（仿函数，如何从Value里拿到Key），Compare（仿函数，如何比较Key）
#include &amp;lt;bits/stl_tree.h&amp;gt; int main() { struct MyS { int a; int b; }; struct GetKey { int operator()(const MyS &amp;amp;s) const { return s.a; } }; //key, key and data = value, how to get key from value, compare, allocator(default) std::_Rb_tree&amp;lt;int, MyS, GetKey, std::less&amp;lt;int&amp;gt;&amp;gt; rbTree; rbTree.</description>
    </item>
    
    <item>
      <title>C&#43;&#43;小知识</title>
      <link>https://yuyoung32.github.io/post/c&#43;&#43;%E5%B0%8F%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Tue, 09 Aug 2022 23:25:36 +0800</pubDate>
      
      <guid>https://yuyoung32.github.io/post/c&#43;&#43;%E5%B0%8F%E7%9F%A5%E8%AF%86/</guid>
      <description>左右值和左右值引用 左值： 可以取地址，有名字的，非临时的就是左值。
右值： 不能取地址，没有名字的，临时的就是右值。
左值引用： 相当于指针指向某个左值，取了左值的地址。就是说左值引用要求右边的值可以取地址，若不能取地址可以，像这样const int&amp;amp; a = 1;实际是创建临时变量。
右值引用： 相当于指针指向某个右值，右值没有地址意味着创建了临时变量来存储。类似于左值引用使用const，但是使用了const无法修改，这里可以修改。
为何会有左右值？引用实际上就是简化了指针，或者说内存标识符。为了精确控制内存生命周期，避免没必要的内存拷贝。
例如：在深拷贝时，直接将传入的右值内存拿过来，因为右值是临时创建的，不可能再用。可移动对象在需要拷贝且被拷贝者之后不再被需要的场景，可以使用 std::move 将左值转换成右值，提升性能。但如果像将右值转换成左值怎么办？std::forward&amp;lt;T&amp;gt;(rlValue)，会左转右或右转左。
构造函数初始化列表 在函数下面直接冒号对成员变量赋值。
为什么要使用这个？
不是所有成员都可以通过形参赋值的，比如引用类型，const类型。 为了一些性能原因，对于类里面有声明类的话，编译器会先把里面声明的类构建一下，然后再进入构造函数类型，再调用赋值拷贝函数，然后再析构最初初始化的类。使用初始化列表后，就会在外面的类初始化的适合就直接把传入的参数给它了，就不会再初始化了。省去了3步：最初的构建函数，最初的构建好的类的析构函数，赋值拷贝函数。 int cnt = 0; class MyClassB { public: MyClassB(){std::cout &amp;lt;&amp;lt; &amp;#34;constructorB called&amp;#34; &amp;lt;&amp;lt; cnt++ &amp;lt;&amp;lt; std::endl;} ~MyClassB(){std::cout &amp;lt;&amp;lt; &amp;#34;destructorB called&amp;#34; &amp;lt;&amp;lt; cnt++ &amp;lt;&amp;lt; std::endl;} MyClassB &amp;amp;operator=(MyClassB b) { std::cout &amp;lt;&amp;lt; &amp;#34;operator= called&amp;#34; &amp;lt;&amp;lt; cnt++ &amp;lt;&amp;lt; std::endl; return *this; } }; class MyClassA { public: MyClassA(MyClassB b) //或初始化列表 :bina(b) { bina=b; std::cout &amp;lt;&amp;lt; &amp;#34;constructorA called&amp;#34; &amp;lt;&amp;lt; cnt++ &amp;lt;&amp;lt; std::endl; } ~MyClassA(){std::cout &amp;lt;&amp;lt; &amp;#34;destructorA called&amp;#34; &amp;lt;&amp;lt; cnt++ &amp;lt;&amp;lt; std::endl;} MyClassB bina; }; int main() { MyClassB b; MyClassA a(b); } 初始化列表输出：</description>
    </item>
    
  </channel>
</rss>
