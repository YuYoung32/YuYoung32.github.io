<!DOCTYPE html>
<html lang="zh">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="generator" content="Hugo 0.111.3">
  <title> C&#43;&#43;小知识 | YuYoung&#39;s Blog </title>
  <meta name="description" content="YuYoung的博客">
  <link rel="stylesheet" href="https://yuyoung32.github.io/css/simpleness.css">
  <link rel="canonical" href="https://yuyoung32.github.io/post/c&#43;&#43;%E5%B0%8F%E7%9F%A5%E8%AF%86/">
  <link rel="alternate" type="application/rss+xml" href="" title="YuYoung&#39;s Blog">
  
  
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css" rel="stylesheet">
  
  
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6QCN1ZG6DB"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-6QCN1ZG6DB', { 'anonymize_ip': false });
}
</script>

  
</head>
<body class="container">
  <nav class="navigation">
  <div class="nav-left">
    
    <div class="nav-item nav-title">
      <a href="https://yuyoung32.github.io/"> YuYoung&#39;s Blog</a>
    </div>
    <div class="nav-item nav-menu">
      
      <a href="/"> Home</a>
      
      <a href="/about/"> About</a>
      
    </div>
  </div>
  <div class="nav-item nav-right fontawesome">
    
    
    <a href="https://github.com/YuYoung32" target="_blank">
      <i title="GitHub" class="fab fa-github"></i>
    </a>
    
    
    <a href="https://yuyoung32.github.io/index.xml" target="_blank">
      <i title="RSS" class="fas fa-rss"></i>
    </a>
    
  </div>
</nav>

  
<article class="post">
  <header class="post-header">
    <h1 style="text-align: center;" >C&#43;&#43;小知识</h1>
    <div class="post-metadata">
    
      <time datetime="2022-08-09T23:25:36&#43;08:00">August 09, 2022</time> &nbsp; 
    
    
    
    
    
    
      <i class="fas fa-folder"></i>
      
      <a href="/categories/c&#43;&#43;">c&#43;&#43;</a>
      &nbsp;
      
    
    </div>
  </header>

  
  <div class="post-toc">
    <div class="post-toc-title">-目录-</div>
    <nav id="TableOfContents">
  <ul>
    <li><a href="#构造函数初始化列表">构造函数初始化列表</a></li>
    <li><a href="#模板">模板</a>
      <ul>
        <li><a href="#模板函数">模板函数</a></li>
        <li><a href="#具体化specialization和实例化instantiation">具体化Specialization和实例化Instantiation</a></li>
        <li><a href="#重载解析">重载解析</a></li>
        <li><a href="#decltype-和-auto">decltype 和 auto</a></li>
        <li><a href="#模板类">模板类</a></li>
        <li><a href="#模板参数">模板参数</a></li>
        <li><a href="#二阶段名字查找">二阶段名字查找</a></li>
        <li><a href="#模板元编程">模板元编程</a></li>
        <li><a href="#sfinae">SFINAE</a></li>
        <li><a href="#折叠表达式">折叠表达式</a></li>
      </ul>
    </li>
    <li><a href="#函数指针分析">函数指针分析</a></li>
    <li><a href="#仿函数">仿函数</a></li>
    <li><a href="#存储持续性和链接性">存储持续性和链接性</a></li>
    <li><a href="#虚函数和纯虚函数">虚函数和纯虚函数</a></li>
    <li><a href="#存储区">存储区</a></li>
    <li><a href="#成员函数const和mutable">成员函数const和mutable</a></li>
    <li><a href="#友元函数">友元函数</a></li>
    <li><a href="#多继承">多继承</a></li>
    <li><a href="#内存对齐">内存对齐</a></li>
    <li><a href="#类型转换">类型转换</a>
      <ul>
        <li><a href="#dynamic_cast">dynamic_cast</a></li>
        <li><a href="#static_cast">static_cast</a></li>
        <li><a href="#reinterpret_cast">reinterpret_cast</a></li>
        <li><a href="#const_cast">const_cast</a></li>
        <li><a href="#例子类之间的转换">例子：类之间的转换</a></li>
      </ul>
    </li>
    <li><a href="#生命周期函数">生命周期函数</a>
      <ul>
        <li><a href="#三法则">三法则</a></li>
        <li><a href="#五法则">五法则</a></li>
        <li><a href="#显式声明-noexcept">显式声明 noexcept</a></li>
        <li><a href="#自动生命周期顺序">自动生命周期顺序</a></li>
      </ul>
    </li>
    <li><a href="#其他">其他</a>
      <ul>
        <li><a href="#模板里的typename">模板里的typename</a></li>
        <li><a href="#typeid-比较类型">typeid 比较类型</a></li>
        <li><a href="#tuple-pair-tie">tuple pair tie</a></li>
        <li><a href="#设置entry_point">设置entry_point</a></li>
        <li><a href="#embedded-pointer">embedded pointer</a></li>
        <li><a href="#trivial类型和standard-layout">Trivial类型和Standard Layout</a></li>
        <li><a href="#返回值优化">返回值优化</a></li>
        <li><a href="#auto">auto</a></li>
        <li><a href="#stdbegin-end">std::begin end</a></li>
        <li><a href="#通用初始化">通用初始化</a></li>
        <li><a href="#字面量后缀">字面量后缀</a></li>
        <li><a href="#stdbitset">std::bitset</a></li>
        <li><a href="#static_assert">static_assert</a></li>
        <li><a href="#enum-class">enum class</a></li>
        <li><a href="#stdchrono">std::chrono</a></li>
        <li><a href="#stdrandom">std::random</a></li>
        <li><a href="#stdany">std::any</a></li>
        <li><a href="#stdoptional">std::optional</a></li>
        <li><a href="#stdvarient">std::varient</a></li>
        <li><a href="#stderror_code-error_condition">std::error_code error_condition</a></li>
        <li><a href="#视图">视图</a></li>
        <li><a href="#stdfunction">std::function</a></li>
        <li><a href="#currying柯里化">Currying（柯里化）</a></li>
        <li><a href="#if-constexpr">if constexpr</a></li>
      </ul>
    </li>
    <li><a href="#多线程">多线程</a>
      <ul>
        <li><a href="#多线程库">多线程库</a></li>
        <li><a href="#互斥操作">互斥操作</a></li>
        <li><a href="#机器执行时的内存读写顺序">机器执行时的内存读写顺序</a></li>
      </ul>
    </li>
    <li><a href="#智能指针">智能指针</a></li>
  </ul>
</nav>
  </div>
  

  <div class="post-text">
    <h2 id="构造函数初始化列表">构造函数初始化列表</h2>
<p>在函数下面直接冒号对成员变量赋值。</p>
<p>为什么要使用这个？</p>
<ol>
<li>不是所有成员都可以通过形参赋值的，比如引用类型，const类型。</li>
<li>为了一些性能原因，对于类里面有声明类的话，编译器会先把里面声明的类构建一下，然后再进入构造函数类型，再调用赋值拷贝函数，然后再析构最初初始化的类。使用初始化列表后，就会在外面的类初始化的适合就直接把传入的参数给它了，就不会再初始化了。省去了3步：最初的构建函数，最初的构建好的类的析构函数，赋值拷贝函数。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClassB</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    MyClassB(){std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;constructorB called&#34;</span> <span style="color:#f92672">&lt;&lt;</span> cnt<span style="color:#f92672">++</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;}
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">~</span>MyClassB(){std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;destructorB called&#34;</span> <span style="color:#f92672">&lt;&lt;</span> cnt<span style="color:#f92672">++</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;}
</span></span><span style="display:flex;"><span>    MyClassB <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(MyClassB b)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;operator= called&#34;</span> <span style="color:#f92672">&lt;&lt;</span> cnt<span style="color:#f92672">++</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClassA</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    MyClassA(MyClassB b)
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//或初始化列表 :bina(b)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    {
</span></span><span style="display:flex;"><span>        bina<span style="color:#f92672">=</span>b;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;constructorA called&#34;</span> <span style="color:#f92672">&lt;&lt;</span> cnt<span style="color:#f92672">++</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">~</span>MyClassA(){std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;destructorA called&#34;</span> <span style="color:#f92672">&lt;&lt;</span> cnt<span style="color:#f92672">++</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;}
</span></span><span style="display:flex;"><span>    MyClassB bina;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    MyClassB b;
</span></span><span style="display:flex;"><span>    MyClassA a(b);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>初始化列表输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>constructorB called0 main.B构建
</span></span><span style="display:flex;"><span>constructorA called1 main.A构建
</span></span><span style="display:flex;"><span>destructorB called2  析构形参B
</span></span><span style="display:flex;"><span>destructorA called3  析构main.A 对应1
</span></span><span style="display:flex;"><span>destructorB called4  A.B 析构自己
</span></span><span style="display:flex;"><span>destructorB called5  析构main.B 对应0
</span></span></code></pre></div><p>=赋值输出：标有*的是多的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>constructorB called0 main.B构建
</span></span><span style="display:flex;"><span>* constructorB called1 A.B初始化构建
</span></span><span style="display:flex;"><span>* operator= called2    A.B赋值
</span></span><span style="display:flex;"><span>* destructorB called3  A.B初始化时的类析构 对应1
</span></span><span style="display:flex;"><span>constructorA called4 main.A构建
</span></span><span style="display:flex;"><span>destructorB called5  析构形参B
</span></span><span style="display:flex;"><span>destructorA called6  main.A析构 对应4
</span></span><span style="display:flex;"><span>destructorB called7  A.B析构
</span></span><span style="display:flex;"><span>destructorB called8  main.B析构 对应0
</span></span></code></pre></div><h2 id="模板">模板</h2>
<p>有了重载为什么需要模板？仅仅<strong>参数类型不同</strong>的情况下，重载还需要一个一个写。而模板传入类型，直接就可以用一个函数补齐所有类型了，这个过程叫做具体化。而且任何类型都可以，哪怕未知的类型。模板不会减少执行代码量，他会生成不同的代码，因此需要控制代码膨胀体积。</p>
<h3 id="模板函数">模板函数</h3>
<p>用法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span><span style="color:#75715e">//或template&lt;class T&gt;，二者完全相同
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> func(T arg){}
</span></span></code></pre></div><p>模板函数同样可以重载。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> func(T arg){}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//重新声明
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> func(T arg1, T arg2){}
</span></span></code></pre></div><h3 id="具体化specialization和实例化instantiation">具体化Specialization和实例化Instantiation</h3>
<p><strong>具体化Specialization和实例化Instantiation的区别？</strong></p>
<p>模板先具体化类型确定签名，然后实例化生成代码。</p>
<p><strong>具体化</strong></p>
<p>具体化是指针对某些特定类型参数或条件，定义一份特殊实现的模板代码实现，类似于重载。</p>
<p>显式具体化</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">my_class</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 类模板成员定义
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 显式具体化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">my_class</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> { <span style="color:#75715e">// 语法上，在实现的&lt;&gt;里明确类型, 用不到前面的就不要加
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 对 int 类型的实现
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 显式具体化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">my_class</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">*&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 对 T* 类型的实现
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 重载约等于显式具体化+实例化, 不要混用显式具体化和重载！
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> my_func(<span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> t) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 函数模板代码实现
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">my_func</span>(<span style="color:#66d9ef">double</span> t) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 重载代码实现
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>隐式具体化</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> my_func(<span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> t) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 函数模板代码实现
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;
</span></span><span style="display:flex;"><span>    my_func(x); <span style="color:#75715e">// 隐式具体化+实例化，会自动生成 my_func&lt;int&gt;(const int&amp;) 实例化版本
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p><strong>实例化</strong></p>
<p>实例化是指将模板加上具体类型<strong>转化为具体的代码</strong>。</p>
<p>显式实例化</p>
<p>要求编译器在编译时将该模板独立地实例化出来，而不是运行时确定。在显式实例化时因为是指示编译器去生成代码，因此<strong>禁止定义</strong>。这里只能直接分号结尾。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#66d9ef">void</span> my_func<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(<span style="color:#66d9ef">int</span>); <span style="color:#75715e">// 语法上，template后面没有&lt;&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//在其他文件里 需要 extern template void my_func&lt;int&gt;(int); 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#66d9ef">void</span> my_func<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(<span style="color:#66d9ef">int</span>){}<span style="color:#75715e">// 错误
</span></span></span></code></pre></div><p>隐式实例化</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> my_func(<span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> t) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 函数模板代码实现
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;
</span></span><span style="display:flex;"><span>    my_func(x); <span style="color:#75715e">// 隐式具体化+实例化，会自动生成 my_func&lt;int&gt;(const int&amp;) 实例化版本
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p><strong>为什么需要显式具体化？</strong></p>
<p>对于某些类型需要特例处理。</p>
<p><strong>显式具体化和函数重载的区别？</strong></p>
<p>函数重载的匹配优先级大于显式具体化。</p>
<p>优先级：函数重载&gt;显式具体化&gt;模板函数。</p>
<p><strong>全特化（Full Specialization）和偏特化（Partial Specialization）</strong></p>
<p>全具体化也叫<strong>全特化</strong>。</p>
<p>片段具体化也叫<strong>偏特化</strong>。</p>
<p>全特化（Full Specialization）是指针对模板中<strong>所有的参数类型</strong>都进行了具体化。</p>
<p>偏特化（Partial Specialization）则是指模板参数列表只有部分被具体化了。一般来说，偏特化版本可以针对某个或多个模板参数进行特化，但至少有一个模板参数需要保留为未指定类型，从而仍然需要依靠实例化时进行推导。</p>
<p>举例如下。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// 基础模板
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> TA, <span style="color:#66d9ef">typename</span> TB<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClass</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 全特化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClass</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 偏特化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> TA<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClass</span><span style="color:#f92672">&lt;</span>TA, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>其中，模板函数只有全特化，<strong>没有部分特化</strong>。要实现部分特化应当使用函数重载或者仿函数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> TA, <span style="color:#66d9ef">typename</span> TB<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> func(TA a, TB b) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 全特化 正确
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> func(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 偏特化 错误！
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> TA<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> func<span style="color:#f92672">&lt;</span>TA, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(TA a, <span style="color:#66d9ef">int</span> b) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 偏特化 错误！
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> TA, <span style="color:#66d9ef">typename</span> TB<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> func<span style="color:#f92672">&lt;</span>TA, TA<span style="color:#f92672">&gt;</span>(TA a, TA b) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 属于重载 因为语法上 func后面没有&lt;&gt;来指定具体类型 否则就属于具体化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> TA<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> func(TA a, TA b) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="重载解析">重载解析</h3>
<p>调用函数时，选择哪个函数？</p>
<p>执行顺序：</p>
<ol>
<li>函数名正确</li>
<li>参数数量正确</li>
<li>匹配函数参数类型
<ol>
<li>完全匹配，常规函数优于模板函数</li>
<li>类型提升转换</li>
<li>类型标准转换</li>
<li>类型自定义转换</li>
</ol>
</li>
</ol>
<h3 id="decltype-和-auto">decltype 和 auto</h3>
<p>二者都作为类型推断，都是C++11新增的<strong>关键字</strong>。<code>decltype</code>是为了解决模板里，不同类型运算后最终类型无法确定的问题。</p>
<p><strong>语法格式：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> varname <span style="color:#f92672">=</span> value;  <span style="color:#75715e">//auto的语法格式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">decltype</span>(exp) varname [<span style="color:#f92672">=</span> value];  <span style="color:#75715e">//decltype的语法格式
</span></span></span></code></pre></div><p>decltype对于输入的不同获取类型是不同的</p>
<ul>
<li>
<p>decltype(变量名)获取精确类型</p>
</li>
<li>
<p>decltype(表达式)，若表达式结果是广义左值类型则返回引用，若是纯右值则获取精确类型</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">decltype</span>(a) <span style="color:#960050;background-color:#1e0010">推断为</span> <span style="color:#66d9ef">int</span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">decltype</span>((a)) <span style="color:#960050;background-color:#1e0010">推断为</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">decltype</span>(a<span style="color:#f92672">+</span>a) <span style="color:#960050;background-color:#1e0010">推断为</span> <span style="color:#66d9ef">int</span>;
</span></span></code></pre></div></li>
</ul>
<p><strong>主要区别：</strong></p>
<ul>
<li><code>auto</code>需要右边的值并且真的运行出来，而<code>decltype</code>只是编译期根据表达式<code>exp</code>的类型做推断，不需要右边的<code>value</code>的任何东西，也不会运行<code>exp</code>。</li>
<li><code>decltype</code>可以保留exp的引用、const等信息。</li>
</ul>
<p><strong>另外：</strong></p>
<p>在函数体内，<code>decltype</code>可以很好运转，但是<strong>在返回时怎么办呢</strong>。返回值内的表达式<code>exp</code>是局部变量无法访问到。</p>
<p>于是有了后置返回类型（trailing return type）</p>
<p>模板函数可以这样写：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T1, <span style="color:#66d9ef">typename</span> T2<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> add(T1 t1, T2 t2) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">decltype</span>(t1 <span style="color:#f92672">+</span> t2)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> t1 <span style="color:#f92672">+</span> t2;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>普通函数也可以这样写</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> <span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">float</span> b) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">double</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> a <span style="color:#f92672">+</span> b;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="模板类">模板类</h3>
<p>大部分和模板函数一致，但是要注意模板类实例化时必须显式通过&lt;&gt;指定类型！不像模板函数可加可不加。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClass</span>{};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> my_func(T t);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//必须&lt;&gt;指明类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>MyClass<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> mc;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>my_func<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">//或者
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>my_func(<span style="color:#ae81ff">1</span>);
</span></span></code></pre></div><h3 id="模板参数">模板参数</h3>
<p>模板参数不只是类型，也可以是非类型值和模板。其中非类型的值是有限制的，一般是整数类型：各种整数、指针。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> VecWrap <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 对std::vector进行了封装 使其模板参数只有一个入参 并且自带了reserve
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Inner<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">typename</span> Outer, <span style="color:#66d9ef">int</span> Num<span style="color:#f92672">&gt;</span> <span style="color:#75715e">// Inner只是一个占位符 模板参数如果是模板则不能看作一整个typename, 需要写出整个模板参数的模板声明
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyVector</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    MyVector() {
</span></span><span style="display:flex;"><span>        myVector.reserve(Num);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Outer<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> myVector;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    MyVector<span style="color:#f92672">&lt;</span>VecWrap, <span style="color:#ae81ff">10</span><span style="color:#f92672">&gt;</span> v;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//MyVector&lt;std::vector&lt;int&gt;, int&gt; myTemplate2; //Outer模板只有一个参数需要using进行类型定义
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> v.myVector.capacity() <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl; <span style="color:#75715e">//10
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>模板参数也可以是有名字和无名。</p>
<table>
<thead>
<tr>
<th>有无默认值</th>
<th>有名字</th>
<th>无名字</th>
</tr>
</thead>
<tbody>
<tr>
<td>无默认值</td>
<td><code>template&lt;typename T&gt;</code></td>
<td><code>template&lt;typename&gt;</code></td>
</tr>
<tr>
<td>有默认值</td>
<td><code>template&lt;typename T = int&gt;</code></td>
<td><code>template&lt;typename = int&gt;</code></td>
</tr>
<tr>
<td>无默认值的可变数量</td>
<td><code>template&lt;typename... T&gt;</code></td>
<td><code>template&lt;typename...&gt;</code></td>
</tr>
</tbody>
</table>
<h3 id="二阶段名字查找">二阶段名字查找</h3>
<p>没有实例化的类是不存在的。</p>
<p>对于依赖模板参数的类需要在实例化后才能得到类里的成员。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> f() {};
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> a;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Derived</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Base<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> b() {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//f(); //错误, 对于依赖模板参数的名字， 编译时会在模板实例化时(运行时)查找
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//a; //错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>f();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>a;
</span></span><span style="display:flex;"><span>        Base<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>f();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Derived2</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Base<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> b() {
</span></span><span style="display:flex;"><span>        f(); <span style="color:#75715e">//正确, 运行到这里《 已经实例化了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="模板元编程">模板元编程</h3>
<p>模板元编程充分利用类型系统。</p>
<p><strong>类型推导</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Fn, <span style="color:#66d9ef">typename</span>... Args<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">result_of_impl</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">using</span> type <span style="color:#f92672">=</span> <span style="color:#66d9ef">typename</span> std<span style="color:#f92672">::</span>result_of<span style="color:#f92672">&lt;</span>Fn(Args...)<span style="color:#f92672">&gt;::</span>type; <span style="color:#75715e">//std::result_of 判断函数调用的返回值类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Fn, <span style="color:#66d9ef">typename</span>... Args<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> result_of_t <span style="color:#f92672">=</span> <span style="color:#66d9ef">typename</span> result_of_impl<span style="color:#f92672">&lt;</span>Fn, Args...<span style="color:#f92672">&gt;::</span>type;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">using</span> F <span style="color:#f92672">=</span> <span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>)(<span style="color:#66d9ef">double</span>);	<span style="color:#75715e">//函数指针的类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">using</span> R <span style="color:#f92672">=</span> result_of_t<span style="color:#f92672">&lt;</span>F, <span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static_assert</span>(std<span style="color:#f92672">::</span>is_same_v<span style="color:#f92672">&lt;</span>R, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>); <span style="color:#75715e">//编译期间判断
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>控制流</strong></p>
<p>条件语句，除了原始的静态重载还有std::conditional、std::enable_if可以用。</p>
<p>原始</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>T max(T a, T b, <span style="color:#66d9ef">bool</span> use_a <span style="color:#f92672">=</span> true) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> use_a <span style="color:#f92672">?</span> a : b;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>T max(T a, T b) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">max</span>(a, b, a <span style="color:#f92672">&gt;=</span> b);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> max(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, false) <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl; <span style="color:#75715e">// 手动输入
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>std::conditional 根据表达式的值选择后面的值</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T1, <span style="color:#66d9ef">typename</span> T2<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">is_same</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">bool</span> value <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">is_same</span><span style="color:#f92672">&lt;</span>T, T<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">bool</span> value <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T1, <span style="color:#66d9ef">typename</span> T2<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> select_type <span style="color:#f92672">=</span> <span style="color:#66d9ef">typename</span> std<span style="color:#f92672">::</span>conditional<span style="color:#f92672">&lt;</span>is_same<span style="color:#f92672">&lt;</span>T1, T2<span style="color:#f92672">&gt;::</span>value, T1, T2<span style="color:#f92672">&gt;::</span>type;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">typeid</span>(select_type<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>).name() <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>std::enable_if 根据一个条件表达式来选择是否实例化一个模板</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T1, <span style="color:#66d9ef">typename</span> T2<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typename</span> std<span style="color:#f92672">::</span>enable_if<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>is_same<span style="color:#f92672">&lt;</span>T1, T2<span style="color:#f92672">&gt;::</span>value, T1<span style="color:#f92672">&gt;::</span>type <span style="color:#75715e">//如果条件不成立则不选择这个模板
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>select_type(T1 a, T2 b) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> a;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T1, <span style="color:#66d9ef">typename</span> T2<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typename</span> std<span style="color:#f92672">::</span>enable_if_t<span style="color:#f92672">&lt;!</span>std<span style="color:#f92672">::</span>is_same<span style="color:#f92672">&lt;</span>T1, T2<span style="color:#f92672">&gt;::</span>value, T2<span style="color:#f92672">&gt;</span> <span style="color:#75715e">//std::enable_if_t自带::type, 不需自行添加 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>select_type(T1 a, T2 b) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> b;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> y <span style="color:#f92672">=</span> <span style="color:#ae81ff">3.14</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> p <span style="color:#f92672">=</span> select_type(x, x); <span style="color:#75715e">// p 的类型为 int
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> q <span style="color:#f92672">=</span> select_type(x, y); <span style="color:#75715e">// q 的类型为 double
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> p <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">&lt;&lt;</span> q <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl; <span style="color:#75715e">// 输出 42 3.14
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>void_t 用于判断是否有某个成员函数，原理是尝试获取返回值类型，若获取失败则不选择该模板</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;type_traits&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T, <span style="color:#66d9ef">typename</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">void</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">has_size</span> <span style="color:#f92672">:</span> std<span style="color:#f92672">::</span>false_type {};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">has_size</span><span style="color:#f92672">&lt;</span>T, std<span style="color:#f92672">::</span>void_t<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">decltype</span>(std<span style="color:#f92672">::</span>declval<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>().size())<span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">:</span> std<span style="color:#f92672">::</span>true_type {}; <span style="color:#75715e">//SFINAE 去实例化其他的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>boolalpha;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> has_size<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string<span style="color:#f92672">&gt;::</span>value <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;  <span style="color:#75715e">// 输出 true，因为 std::string 有 size() 成员函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> has_size<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>value <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;  <span style="color:#75715e">// 输出 false，因为 int 没有 size() 成员函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="sfinae">SFINAE</h3>
<p>Subsituation failure is not an error。实例化失败不是错误。</p>
<p>目的是模板实例化时，如果我们选择重载的话，会提供多个实例化选择。这时当编译器遇到第一个无法实例化的模板的时候继续<strong>查看其他模板能否匹配</strong>，而不是直接error结束编译。</p>
<p>相当于实现了<strong>模板实例化时的“重载”</strong>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;type_traits&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span>... Ts<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> void_t <span style="color:#f92672">=</span> <span style="color:#66d9ef">void</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//#1 否则就实例化这个
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//typename=void 就是一个开关，如果第二选项存在就不使用这个
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T, <span style="color:#66d9ef">typename</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">void</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">has_typedef_foobar</span> <span style="color:#f92672">:</span> std<span style="color:#f92672">::</span>false_type {};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//#2 T::foobar获取成功，那么自然就选择这个进行实例化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">has_typedef_foobar</span><span style="color:#f92672">&lt;</span>T, void_t<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">::</span>foobar<span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">:</span> std<span style="color:#f92672">::</span>true_type {};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">foo</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">using</span> foobar <span style="color:#f92672">=</span> <span style="color:#66d9ef">float</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>boolalpha;
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> has_typedef_foobar<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>value <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;<span style="color:#75715e">//int::foobar失败 进入#1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> has_typedef_foobar<span style="color:#f92672">&lt;</span>foo<span style="color:#f92672">&gt;::</span>value <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;<span style="color:#75715e">//foo::foobar成功 进入#2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h3 id="折叠表达式">折叠表达式</h3>
<p>C++17。表达式必须用<code>()</code>括起来。折叠表达式避免了模板的递归。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span>... Args<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> UniLeft(Args... args) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (... <span style="color:#f92672">+</span> args); <span style="color:#75715e">// (((E1 op E2) op E3) op E4)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span>... Args<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> UniRight(Args... args) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (args <span style="color:#f92672">+</span> ...); <span style="color:#75715e">// (E1 op (E2 op (E3 op E4)))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T, <span style="color:#66d9ef">typename</span>... Args<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> PrintWithSeq(T sep, Args... args) {
</span></span><span style="display:flex;"><span>    ((std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> args <span style="color:#f92672">&lt;&lt;</span> sep), ...); <span style="color:#75715e">// (std::cout &lt;&lt; args[0] &lt;&lt; sep) , (std::cout &lt;&lt; args[1] &lt;&lt; sep)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T, <span style="color:#66d9ef">typename</span>... Args<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> PrintWithSeq2(T sep, Args... args) {
</span></span><span style="display:flex;"><span>    (..., (std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> args <span style="color:#f92672">&lt;&lt;</span> sep)); <span style="color:#75715e">// (std::cout &lt;&lt; args[0] &lt;&lt; sep) , (std::cout &lt;&lt; args[1] &lt;&lt; sep)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span>... Args<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> DubLeft(Args... args) {
</span></span><span style="display:flex;"><span>    (std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> ... <span style="color:#f92672">&lt;&lt;</span> args); <span style="color:#75715e">// (((I op E2) op E3) op E4)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span>... Args<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> DubRight(Args... args) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (args <span style="color:#f92672">=</span> ... <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>); <span style="color:#75715e">// (E1 op (E2 op (E3 op I)))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> sumLeft <span style="color:#f92672">=</span> UniLeft(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> sumRight <span style="color:#f92672">=</span> UniRight(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span>    DubLeft(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>);                 <span style="color:#75715e">//12345
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    DubRight(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span>    PrintWithSeq(<span style="color:#e6db74">&#39;,&#39;</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>);       <span style="color:#75715e">//1,2,3,4,5,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    PrintWithSeq2(<span style="color:#e6db74">&#39;,&#39;</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>);      <span style="color:#75715e">//1,2,3,4,5,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="函数指针分析">函数指针分析</h2>
<p>如何声明一个函数指针？</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">//通用格式：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ReturnType (<span style="color:#f92672">*</span>NickName)(PramType1, PramType2);
</span></span><span style="display:flex;"><span><span style="color:#75715e">//实例
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>func)(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b);
</span></span><span style="display:flex;"><span><span style="color:#75715e">//或者迷惑人一下
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>f)();
</span></span></code></pre></div><p>如上，<code>NickName</code>是调用时使用的，很明显把<code>NickName</code>当作了一个地址。类似的还有<code>int *a;</code>，把<code>*a</code>当作<code>int</code>，那么<code>a</code>就是地址咯。</p>
<p>那么，嵌套一下？</p>
<p><strong>例子1</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>pf())())();
</span></span></code></pre></div><p>可以这样分析：</p>
<ol>
<li>
<p><code>pf()</code>是一个普普通通的函数声明（暂且忽略掉返回值），那么他返回的是剩下的一坨，姑且可以拆分成这样：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>T <span style="color:#a6e22e">pf</span>();
</span></span></code></pre></div></li>
<li>
<p>那么T是什么类型呢，可以看到除去<code>pf()</code>这4个字符后剩下的实际上是有<code>(*)()</code>这样的结构，这是函数指针。所以可以这样声明：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">int</span> (<span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>T)())();
</span></span></code></pre></div><p>此时可以看到T是一个函数指针！，所以最原始的pf函数返回了一个函数指针。</p>
</li>
<li>
<p>T是函数指针，那么*T就是函数咯，此时可以把<code>(*T)()</code>这几个字符拿掉（他们代表了执行<code>*T</code>这个函数），那么可以这样声明：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">int</span> (<span style="color:#f92672">*</span>T2)();
</span></span></code></pre></div><p>此刻就明白了。</p>
</li>
</ol>
<p>最终可以这样简化：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">int</span> (<span style="color:#f92672">*</span>T2)();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">T2</span> (<span style="color:#f92672">*</span>T)();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> T <span style="color:#a6e22e">pf</span>();
</span></span></code></pre></div><p>也可以使用后置类型简化：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> <span style="color:#a6e22e">pf</span>() <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">auto</span> (<span style="color:#f92672">*</span>)() <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>)();
</span></span><span style="display:flex;"><span><span style="color:#75715e">//进行一个实现
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span> <span style="color:#a6e22e">pf</span>() <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">auto</span> (<span style="color:#f92672">*</span>)() <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>)()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> []() <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>)()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> []() <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>例子2</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>fn())(<span style="color:#66d9ef">int</span>))())())();
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">int</span> (<span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>T)(<span style="color:#66d9ef">int</span>))())())();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">int</span> (<span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>T2)())())();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">int</span> (<span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>T3)())();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">int</span> (<span style="color:#f92672">*</span>T4)();
</span></span><span style="display:flex;"><span>T <span style="color:#a6e22e">fn</span>();
</span></span><span style="display:flex;"><span><span style="color:#75715e">//或者
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span> <span style="color:#a6e22e">fn</span>() <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">auto</span> (<span style="color:#f92672">*</span>)(<span style="color:#66d9ef">int</span>) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">auto</span> (<span style="color:#f92672">*</span>)() <span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">auto</span> (<span style="color:#f92672">*</span>)() <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>)();
</span></span></code></pre></div><h2 id="仿函数">仿函数</h2>
<p>一种避免使用函数指针的方式是使用仿函数。如下面传入了一个less函数来构建大顶堆。</p>
<p>仿函数实际上是重载了<code>operator()</code>。这样可以灵活的改变函数内部的参数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span> <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//仿函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">MyLess</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">operator</span>()(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> a, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> b) <span style="color:#66d9ef">const</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> a <span style="color:#f92672">&lt;</span> b;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> v {<span style="color:#ae81ff">8</span>,<span style="color:#ae81ff">9</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">7</span>,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">6</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">1</span>};
</span></span><span style="display:flex;"><span>    priority_queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>,MyLess<span style="color:#f92672">&gt;</span> pq(v.begin(), v.end());
</span></span><span style="display:flex;"><span>    pq.push(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>pq.empty()){
</span></span><span style="display:flex;"><span>        cout <span style="color:#f92672">&lt;&lt;</span> pq.top() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>        pq.pop();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="存储持续性和链接性">存储持续性和链接性</h2>
<p>链接性决定了<strong>编译器在编译时到可不可以到其他文件里找</strong>，静态性决定<strong>当前作用域的变量是否共享内存区</strong>，即不同实例使用同一份内存。可以看到全局变量和函数一旦加了static就不能在其他文件使用了。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>在当前文件定义声明格式</th>
<th>在其他文件中使用时的引用声明格式</th>
<th>链接性</th>
<th>静态性</th>
<th>作用域</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>全局</strong>变量</td>
<td>int a;</td>
<td>extern int a;</td>
<td>外部</td>
<td>是</td>
<td>全局</td>
</tr>
<tr>
<td><strong>全局</strong>变量</td>
<td>static int a;</td>
<td>不可使用</td>
<td>内部</td>
<td>是</td>
<td>当前文件</td>
</tr>
<tr>
<td>函数</td>
<td>void foo();</td>
<td>void foo();</td>
<td>外部</td>
<td>是</td>
<td>全局</td>
</tr>
<tr>
<td>函数</td>
<td>static void foo();</td>
<td>不可使用</td>
<td>内部</td>
<td>是</td>
<td>当前文件</td>
</tr>
<tr>
<td>局部变量</td>
<td>int a;</td>
<td>不可使用</td>
<td>无</td>
<td>否</td>
<td>当前代码块</td>
</tr>
<tr>
<td>局部变量</td>
<td>static int a;</td>
<td>不可使用</td>
<td>无</td>
<td>是</td>
<td>当前代码块</td>
</tr>
</tbody>
</table>
<p>需要注意全局变量和静态全局变量的区别。</p>
<ol>
<li>生命周期：静态全局变量在整个程序的运行期间都存在，而非静态的全局变量的生命周期仅限于它们在程序中的可见范围内。</li>
<li>作用域：静态全局变量只能在定义它们的文件内访问；而非静态的全局变量可以在其他文件中通过 extern 关键字来访问。</li>
<li>初始化方式：非静态的全局变量可以在定义时直接初始化；而静态全局变量只能在定义时初始化，且只能初始化一次。</li>
<li>存储方式：静态全局变量在程序的指定数据段（五大内存区域之一）中分配存储空间；而非静态的全局变量在程序的栈中或堆中分配存储空间。</li>
</ol>
<p><strong>实例：</strong></p>
<p>test1.cpp</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> globalA <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> staticGlobalA <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Fn</span>() {}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span>  <span style="color:#a6e22e">StaticFn</span>() {}
</span></span></code></pre></div><p>test2.cpp</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">int</span> globalA;
</span></span><span style="display:flex;"><span><span style="color:#75715e">//extern int staticGlobalA;  can not use
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Fn</span>(); 
</span></span><span style="display:flex;"><span><span style="color:#75715e">//或 extern void Fn()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//extern void StaticFn();   can not use
</span></span></span></code></pre></div><p>以上都是不用命名空间时整的花活，在使用命名空间后，严格遵循“声明在header，定义在cpp”的规则，使用时引入命名空间就好了，相当于直接把整个东西都拿过来，不管是否是内部还是外部链接性，这时只有静态非静态之分。</p>
<h2 id="虚函数和纯虚函数">虚函数和纯虚函数</h2>
<ol>
<li>
<p>只要某类重写了父类的方法A（virtual），那么子类作为父类类型<strong>指针/引用</strong>传入时，调用方法A，就可以直接使用子类已经重写的方法，而不是父类的方法。若父类的方法不定义为virtual，则还是使用父类的方法。如果还是按照<strong>对象</strong>调用则virtual相当于没有，对象是谁就用谁的。</p>
<p>为什么只有指针才可以？使用对象调用方法属于静态联编，不会考虑对象实际是什么，只用到了对象的类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> foo() {
</span></span><span style="display:flex;"><span>        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Base::foo()&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Derived</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Base {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> foo() {
</span></span><span style="display:flex;"><span>        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Derived::foo()&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    Derived <span style="color:#f92672">*</span>d <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Derived();
</span></span><span style="display:flex;"><span>    d<span style="color:#f92672">-&gt;</span>foo();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">dynamic_cast</span><span style="color:#f92672">&lt;</span>Base <span style="color:#f92672">*&gt;</span>(d)<span style="color:#f92672">-&gt;</span>foo(); <span style="color:#75715e">//向上类型转换，没有丢失数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    Derived dd;
</span></span><span style="display:flex;"><span>    dd.foo();
</span></span><span style="display:flex;"><span>    Base bb <span style="color:#f92672">=</span> dd; <span style="color:#75715e">//进行了赋值拷贝，只将Derived里的Base部分传过来
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    bb.foo();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">Derived::foo()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">Derived::foo()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">Derived::foo()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">Base::foo()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span></code></pre></div><p>在Java里，一个类实现一个Interface，然后就可以作为Interface传入，就可以调用这个类自己实现的方法，C++这里实现机制完全和Java一致了，只不过C++没有interface关键字，强行用class去模拟interface。</p>
<p>在Go里，struct实现了interface后，就可以传入该struct，然后使用该struct实现的interface的方法。其实就是实现了真正意义上的“接口”。</p>
</li>
<li>
<p>override与final</p>
<p>要想明确子类实现的<strong>是</strong>父类的方法，加override关键字在子类实现方法签名里，避免写错。</p>
<p>要想父类拒绝子类override方法，可以加final关键字在子类实现方法签名里，若父类想要拒绝继承，可以在类声明后标记为final<code>class Base final{};</code>。</p>
<p>实现父类方法时，子类方法要满足：函数名、入参、返回值完全一致，但是当返回类的this指针时，返回值可以不一样。</p>
</li>
<li>
<p>虚函数的实现原理</p>
<p>虚函数使用<strong>虚函数表</strong>实现，它是编译期的<strong>静态数组</strong>，类有一个隐藏成员vptr指向它。vptr 是一个指向虚函数表的指针，它是每个包含虚函数的类的非静态成员变量之一，在类的内存布局中被放在<strong>对象的起始地址</strong>处。每个类实现时，都会创建一个虚表，虚表记录了各个虚函数的入口地址，若自己的类有实现，就指向自己的函数，否则指向基类的虚函数。若派生类继续虚下去，则更新地址，不会记录路径上的虚函数。使用<strong>第一个</strong>虚函数就是使用数组的<strong>第一个</strong>元素。</p>
</li>
<li>
<p>纯虚函数和抽象类</p>
<p>在虚函数后=0即为纯虚函数。含有纯虚函数的类成为抽象类，无法实现。子类继承抽象类时应当实现里面的纯虚方法。此处概念和Java的接口-抽象类几乎完全一致。</p>
</li>
<li>
<p>在继承中为什么一般<strong>虚析构函数</strong>，而不是<strong>虚构造函数</strong>？</p>
<p>从类的生命周期谈起，子类需要继承父类的相关数据，所以从父类开始构造，父类构造完子类构造，父类构造函数不能为虚函数，否则父类数据没有。而在析构时，因为是以父类指针调用的子类，从父类指针调用父类的析构方法，如果父类析构函数不设为虚的，那么子类的析构函数将无法调用，可能会引起<strong>内存泄漏</strong>。</p>
</li>
</ol>
<h2 id="存储区">存储区</h2>
<ul>
<li>
<p><strong>栈</strong>：存放函数的参数值，局部变量，函数执行结束时会被自动释放。栈内存分配运算内置于处理器的指令集中，效率高，但是容量有限。</p>
</li>
<li>
<p><strong>堆</strong>（动态内存分配）：通过new和malloc由低到高分配，由delete或free手动释放或者程序结束自动释放。动态内存的生存期人为决定，使用灵活。缺点是容易分配/释放不当容易造成内存泄漏，频繁分配/释放会产生大量内存碎片。 若程序员不释放，程序结束时可能由操作系统回收</p>
</li>
<li>
<p><strong>全局/静态存储区域</strong>：存全局变量，静态变量。程序编译时内存已分配好，并存在于程序整个运行期间，程序结束后由系统统一释放</p>
<p>全局变量和静态变量被分配到同一块内存中。
C 语言中，全局变量又分为初始化的和未初始化的。初始化的全局变量和静态变量在一块区域，未初始化的全局变量与静态变量在相邻的另一块区域。同时未被初始化的对象存储区可以通过 void* 来访问和操纵，程序结束后由系统自行释放。</p>
<p>在 C++ 里面没有区分，他们共同占用同一块内存区。</p>
</li>
<li>
<p><strong>常量区</strong>： 存放常量，程序结束时由系统释放，const + var_id 为右值。</p>
</li>
<li>
<p><strong>程序代码区</strong>： 存放函数体的二进制代码</p>
</li>
</ul>
<h2 id="成员函数const和mutable">成员函数const和mutable</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">C</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">change</span>() <span style="color:#66d9ef">const</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        a <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;<span style="color:#75715e">//错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        b <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;<span style="color:#75715e">//正确
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> a;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">mutable</span> <span style="color:#66d9ef">int</span> b;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>const放在成员函数后面可以让函数不改变类的变量，若又想改变，需要在成员变量前加mutable。</p>
<p>成员函数const保证不更改对象。const对象调用的方法只能是const方法，以此保证const。</p>
<p>当const和非const成员函数共存时，const对象只会调用const成员函数，非const只会调用非const成员函数。</p>
<h2 id="友元函数">友元函数</h2>
<p><strong>解决了什么问题？</strong></p>
<p>非类成员函数可以访问类私有变量</p>
<p>友元函数定义在类内，但不是类的成员函数。</p>
<p><strong>使用场景举例</strong></p>
<p>二元运算符重载，常规<code>C operator+(int a)</code>，使用时必须按照顺序<code>c + 1</code>或<code>c.operator+(1)</code>，而不能<code>1 + c</code>。</p>
<p>此时可以使用类外运算符重载，但是类外访问不到类内变量怎么办？使用友元函数就可以。</p>
<p>此外，像一元运算符<code>&lt;&lt;</code>，必须使用<code>&lt;&lt;</code></p>
<p><strong>遇到问题</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">C</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">+</span>(<span style="color:#66d9ef">int</span> a) <span style="color:#66d9ef">const</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> num <span style="color:#f92672">+</span> a;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> num;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    C c;
</span></span><span style="display:flex;"><span>    cout <span style="color:#f92672">&lt;&lt;</span> c <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;<span style="color:#75715e">//可以
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//cout &lt;&lt; 1 + c;//不可以
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p><strong>解决方案</strong> 友元函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">C</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">+</span>(<span style="color:#66d9ef">int</span> a) <span style="color:#66d9ef">const</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> num <span style="color:#f92672">+</span> a;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">friend</span> <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">+</span>(<span style="color:#66d9ef">int</span> a, C c);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> num;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">+</span>(<span style="color:#66d9ef">int</span> a, C c)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> a <span style="color:#f92672">+</span> c.num;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*更优雅的实现
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">int operator+(int a, C c)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">{
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    return c + a;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    C c;
</span></span><span style="display:flex;"><span>    cout <span style="color:#f92672">&lt;&lt;</span> c <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;<span style="color:#75715e">//可以
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> c;<span style="color:#75715e">//可以了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h2 id="多继承">多继承</h2>
<p>c++ 支持多继承，使用了一些操作让基类们不会冲突。</p>
<ol>
<li>
<p>基类函数/变量冲突？</p>
<p>使用类作用域解析<code>::</code></p>
</li>
<li>
<p>菱形继承创建多个类如何解决？</p>
<p>使用虚基类，可以保证只创建一个基类。否则以下将创建两个。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>{};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">virtual</span> A{};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">C</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">virtual</span> A{};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">D</span> <span style="color:#f92672">:</span> B, C {};
</span></span></code></pre></div></li>
<li>
<p>菱形继承，若D对B，C传不同数据，而BC用这些数据对A的初始化不同怎么办【自动传递信息】？</p>
<p>在虚基类的情况下，这样是不允许的，只能使用默认构造，或者直接在D中显式调用A构造函数。</p>
<p>而在普通基类的情况下，由于各自创建了一个基类，当然可以这样做，而在D中显式调用A构造函数是不可以的。</p>
</li>
</ol>
<h2 id="内存对齐">内存对齐</h2>
<p>首先找到<code>block = min(max(sizeof(member)), pack_pram)</code>，然后从头填充，每一次都分配block大小，下一个如果不能塞进上一个，则另起一个新的block，如果仍有结构体则拆开。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#pragma pack(8)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">A</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> a;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> b;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> c;
</span></span><span style="display:flex;"><span>};<span style="color:#75715e">//16
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">B</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> a;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> c;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> b;
</span></span><span style="display:flex;"><span>};<span style="color:#75715e">//24
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">C</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> a;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> b;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> c;
</span></span><span style="display:flex;"><span>};<span style="color:#75715e">//16
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">D</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> b;
</span></span><span style="display:flex;"><span>};<span style="color:#75715e">//1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">E</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> b;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> a;
</span></span><span style="display:flex;"><span>};<span style="color:#75715e">//4+4=8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma pack(1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">E2</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> b;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> c;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> a;
</span></span><span style="display:flex;"><span>};<span style="color:#75715e">//3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma pack(4)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">F</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> a;
</span></span><span style="display:flex;"><span>    E2 e;
</span></span><span style="display:flex;"><span>};<span style="color:#75715e">//4 //将E2拆开，重新计算pack
</span></span></span></code></pre></div><h2 id="类型转换">类型转换</h2>
<p><strong>C语言暴力版 (type) var 相当于staic_cast</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span> b <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span>)a;
</span></span></code></pre></div><h3 id="dynamic_cast">dynamic_cast</h3>
<p>用于继承体系下，不同层次类间的类型转化，带有安全检查。</p>
<p>在进行反向转换时，即将 Base* 类型的指针转换为 Derived* 类型的指针时，需要注意以下两点：</p>
<ul>
<li>首先需要保证基类指针指向的对象是派生类对象，否则会导致类型不匹配（危险操作）。</li>
<li>其次需要保证<strong>基类中存在虚函数</strong>，因为这样才能通过RTTI获得类型信息，否则 dynamic_cast 无法在运行时检查类型安全性，会导致编译错误。</li>
</ul>
<p>dynamic_cast如果转换失败，则返回 nullptr。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> Eat() {} <span style="color:#75715e">// 需要存在虚函数才能向上转换
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Derived</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Base {
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    Derived d;
</span></span><span style="display:flex;"><span>    Base <span style="color:#f92672">*</span>b <span style="color:#f92672">=</span> <span style="color:#66d9ef">dynamic_cast</span><span style="color:#f92672">&lt;</span>Base <span style="color:#f92672">*&gt;</span>(<span style="color:#f92672">&amp;</span>d);
</span></span><span style="display:flex;"><span>    Base <span style="color:#f92672">*</span>b1 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>d; <span style="color:#75715e">// 自动转化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    Base <span style="color:#f92672">*</span>bb <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Derived();
</span></span><span style="display:flex;"><span>    Derived <span style="color:#f92672">*</span>dd <span style="color:#f92672">=</span> <span style="color:#66d9ef">dynamic_cast</span><span style="color:#f92672">&lt;</span>Derived <span style="color:#f92672">*&gt;</span>(bb);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="static_cast">static_cast</h3>
<p>类型间转换，当然也可以用作dynamic_cast</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span> b <span style="color:#f92672">=</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>(a);
</span></span></code></pre></div><h3 id="reinterpret_cast">reinterpret_cast</h3>
<p>重新解释指针，指针间转换，可以用作dynamic_cast，参数必须是指针，否则出错。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> a;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span><span style="color:#f92672">*</span> b <span style="color:#f92672">=</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">*&gt;</span>(a);
</span></span></code></pre></div><h3 id="const_cast">const_cast</h3>
<p>如果不用const_cast，通过a改变b内存的值根本不可能。        ·</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> b<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>a <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>b;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> pb <span style="color:#f92672">=</span> <span style="color:#66d9ef">const_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">*&gt;</span>(a);
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>pb<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>     <span style="color:#75715e">//int *c = &amp;(*a);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//Cannot initialize a variable of type &#39;int *&#39; with an rvalue of type &#39;const int *&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>a <span style="color:#f92672">&lt;&lt;</span> endl; <span style="color:#75715e">// 2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h3 id="例子类之间的转换">例子：类之间的转换</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> PrintA() {
</span></span><span style="display:flex;"><span>        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;A&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> A {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> PrintB() {
</span></span><span style="display:flex;"><span>        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;B&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PrintA</span>() {
</span></span><span style="display:flex;"><span>        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Derived A&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    A a, <span style="color:#f92672">*</span>pa;
</span></span><span style="display:flex;"><span>    B b, <span style="color:#f92672">*</span>pb;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//子类使用父类方法 天经地义
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//直接使用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    b.PrintA();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//dynamic cast
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">dynamic_cast</span><span style="color:#f92672">&lt;</span>A <span style="color:#f92672">*&gt;</span>(<span style="color:#f92672">&amp;</span>b)<span style="color:#f92672">-&gt;</span>PrintA();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//static cast
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>A <span style="color:#f92672">*&gt;</span>(<span style="color:#f92672">&amp;</span>b)<span style="color:#f92672">-&gt;</span>PrintA();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//父类使用子类方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//直接使用，当然不行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//a.PrintB();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//隐式类型转换 不可以
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//pa = &amp;b;pa-&gt;PrintB();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//dynamic_cast 可以， 但是需要父类有virtual方法，否则编译不通过，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// dynamic_cast 进行类型转换，vptr的值会指向新的类的虚函数表，从而保证了动态绑定的正确性。因此可以调用，a中没有B的数据，若B的方法使用数据则UB/
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">dynamic_cast</span><span style="color:#f92672">&lt;</span>B <span style="color:#f92672">*&gt;</span>(<span style="color:#f92672">&amp;</span>a)<span style="color:#f92672">-&gt;</span>PrintB();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//dynamic_cast&lt;B *&gt;(&amp;a)-&gt;PrintA(); 出错，转换后发现应当调用B override的PrintA，但是a中没有B的数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//强制类型转换 不可以
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//((A*)b)-&gt;PrintA();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//static_cast 可以
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>B <span style="color:#f92672">*&gt;</span>(<span style="color:#f92672">&amp;</span>a)<span style="color:#f92672">-&gt;</span>PrintB();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="生命周期函数">生命周期函数</h2>
<p>C++中6个类的生命周期函数如下：</p>
<ol>
<li>构造函数 — 用于初始化对象的状态</li>
<li>复制构造函数 — 用于从一个已有对象创建新对象</li>
<li>移动构造函数 — 用于从一个可被移动的对象创建新对象</li>
<li>复制赋值运算符 — 用于将一个对象的状态复制到另一个对象中</li>
<li>移动赋值运算符 — 用于将一个可被移动的对象的状态移动到另一个对象中</li>
<li>析构函数 — 用于清理对象在内存中分配的资源</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">C</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    C() {}
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">~</span>C() {}
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    C(<span style="color:#66d9ef">const</span> C <span style="color:#f92672">&amp;</span>) {}
</span></span><span style="display:flex;"><span>    C(C <span style="color:#f92672">&amp;&amp;</span>) {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    C <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> C <span style="color:#f92672">&amp;</span>) { <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>; }
</span></span><span style="display:flex;"><span>    C <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(C <span style="color:#f92672">&amp;&amp;</span>) { <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>; }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><table>
<thead>
<tr>
<th>名称</th>
<th>形式</th>
<th>默认提供</th>
<th>惯用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认构造</td>
<td><code>C()</code></td>
<td>用户没有提供其他构造函数时，编译器提供</td>
<td>=default</td>
</tr>
<tr>
<td>拷贝构造</td>
<td><code>C(const C&amp;)</code></td>
<td>用户没有提供时，编译器提供；当用户提供<strong>移动构造</strong>或<strong>移动赋值运算符</strong>时，会=delete</td>
<td>=delete</td>
</tr>
<tr>
<td>拷贝赋值运算符</td>
<td><code>operator=(const C&amp;)</code></td>
<td>用户没有提供时，编译器提供；当用户提供<strong>移动构造</strong>或<strong>移动赋值运算符</strong>时，会=delete</td>
<td>和拷贝构造一起存在或删除</td>
</tr>
<tr>
<td>移动构造</td>
<td><code>C(C&amp;&amp;)</code></td>
<td>用户不声明除了默认构造函数外的任一生命函数（4个），编译器会提供</td>
<td>一般不=default或=delete</td>
</tr>
<tr>
<td>移动赋值运算符</td>
<td><code>operator=(C&amp;&amp;)</code></td>
<td>用户不声明除了默认构造函数外的任一生命函数（4个），编译器会提供</td>
<td>一般不=default或=delete</td>
</tr>
<tr>
<td>析构函数</td>
<td><code>~C()</code></td>
<td>用户没有提供时，编译器提供</td>
<td>基类=default</td>
</tr>
</tbody>
</table>
<h3 id="三法则">三法则</h3>
<p>任何想要手动管理资源或内存的类都应声明全部以下五个成员函数</p>
<ul>
<li>拷贝构造</li>
<li>拷贝赋值运算符</li>
<li>析构函数</li>
</ul>
<h3 id="五法则">五法则</h3>
<p>任何想要移动语义的类都应声明全部以下五个成员函数</p>
<ul>
<li>拷贝构造</li>
<li>拷贝赋值运算符</li>
<li>移动构造</li>
<li>移动赋值运算符</li>
<li>析构函数</li>
</ul>
<h3 id="显式声明-noexcept">显式声明 noexcept</h3>
<p>为了保证强异常安全，有一些生命周期成员函数不允许抛异常，需要显式声明noexcept，例如move相关成员函数。</p>
<p>默认noexcept：隐式声明的函数是noexcept。</p>
<p>如vector在内存重分配时期望使用noexcept的移动构造。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">C</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    C() <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">~</span>C() <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    C(<span style="color:#66d9ef">const</span> C <span style="color:#f92672">&amp;</span>) {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;copy constructor&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    C(C <span style="color:#f92672">&amp;&amp;</span>) <span style="color:#66d9ef">noexcept</span> <span style="color:#75715e">/*显式声明noexcept才会被容器默认调用*/</span> {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;move constructor&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>C<span style="color:#f92672">&gt;</span> v;
</span></span><span style="display:flex;"><span>    v.reserve(<span style="color:#ae81ff">3</span>);                   <span style="color:#75715e">// 为了避免内存重新分配造成额外move
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    C c1, c2;
</span></span><span style="display:flex;"><span>    v.emplace_back(c1);             <span style="color:#75715e">// copy constructor
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    v.emplace_back(std<span style="color:#f92672">::</span>move(c2));  <span style="color:#75715e">// move constructor
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    v.emplace_back(C());            <span style="color:#75715e">// move constructor
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    v.emplace_back(C());            <span style="color:#75715e">// move constructor
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 触发扩容，重新分配内存，将原来的元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 1. 若是有noexcept的move constructor，就会调用move constructor
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 2. 若是没有noexcept的move constructor，就会调用copy constructor
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>vector.emplace_back()是在最后位置构造参数，不涉及再次拷贝，是在传入时根据传入的左值右值类型来调用copy constructor或者move constructor。在vector内部调用时会调用noexcept的move constructor，否则就调用copy constructor。</p>
<h3 id="自动生命周期顺序">自动生命周期顺序</h3>
<ol>
<li>栈式析构，后创建的先析构。对于全局和静态的 与 局部的，各自单独计算栈。局部的在<code>}</code>时析构，而全局和静态的在<code>}</code>后析构</li>
<li>全局/静态变量在进入main之前构造</li>
<li>函数（局部）静态对象在第一次执行到声明语句时创建</li>
<li>函数（局部）对象在定义时构造，在定义所在的右大括号析构</li>
<li>临时对象在当前执行语句完成后析构，在赋值给引用变量会延长至和引用一致。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    A() {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;A()&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">~</span>A() {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;~A()&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span> {
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">D</span>{
</span></span><span style="display:flex;"><span>...<span style="color:#960050;background-color:#1e0010">定义类似于</span>A
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>C c;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    A <span style="color:#f92672">*</span>pa <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> A();
</span></span><span style="display:flex;"><span>    B b;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> D d;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">delete</span> pa;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * C()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * A()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * B()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * D()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * ~A()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * ~B()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * ~D() D晚于局部变量B析构 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * ~C()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span></code></pre></div><h2 id="其他">其他</h2>
<h3 id="模板里的typename">模板里的typename</h3>
<p>在模板函数里可以帮助编译器区分static成员和类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>Class MyClass
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">typename</span> T<span style="color:#f92672">::</span>SubType <span style="color:#f92672">*</span> ptr;
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><a href="https://stackoverflow.com/questions/1600936/officially-what-is-typename-for">c++ - Officially, what is typename for? - Stack Overflow</a></p>
<h3 id="typeid-比较类型">typeid 比较类型</h3>
<p>需包含<!-- raw HTML omitted --></p>
<p>属于RTTI（run-time type information）的一部分。</p>
<h3 id="tuple-pair-tie">tuple pair tie</h3>
<p><strong>tuple</strong></p>
<p>元组，融合任意类型和任意个数个元素。一旦形成，不可再改变长度。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;tuple&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> Ty1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">int</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> Ty2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">float</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    Ty1 e1;
</span></span><span style="display:flex;"><span>    Ty2 e2;
</span></span><span style="display:flex;"><span>    tuple<span style="color:#f92672">&lt;</span>Ty1,Ty2<span style="color:#f92672">&gt;</span> t1(e1,e2);       <span style="color:#75715e">//直接构造
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> t2 <span style="color:#f92672">=</span> make_tuple(e1,e2);    <span style="color:#75715e">//通过make_tuple构造
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    get<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0</span><span style="color:#f92672">&gt;</span>(t1);                     <span style="color:#75715e">//通过get获取元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    size_t v1 <span style="color:#f92672">=</span> tuple_size<span style="color:#f92672">&lt;</span>tuple<span style="color:#f92672">&lt;</span>Ty1,Ty2<span style="color:#f92672">&gt;&gt;::</span>value;        <span style="color:#75715e">//获取元素个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    size_t v2 <span style="color:#f92672">=</span> tuple_size_v<span style="color:#f92672">&lt;</span>tuple<span style="color:#f92672">&lt;</span>Ty1,Ty2<span style="color:#f92672">&gt;&gt;</span>;             <span style="color:#75715e">//c++14 获取元素个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    tuple_element<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0</span>, tuple<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;&gt;::</span>type t;           <span style="color:#75715e">//获取类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> cat <span style="color:#f92672">=</span> tuple_cat(t1,t2);    <span style="color:#75715e">//合并元组, 编译期运作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>内部实现是利用模板可变参数递归解开的特点实例化一个继承类的链条。每个类仅有一个成员。</p>
<p><strong>pair</strong></p>
<p>相当于只存两个元素的tuple</p>
<p><strong>tie</strong></p>
<p>用于解包多返回值，在C++17中被结构化绑定取代。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>multimap<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> m;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>multimap<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator lower, upper;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>tie(lower, upper) <span style="color:#f92672">=</span> m.equal_range(<span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> [lower2, upper2] <span style="color:#f92672">=</span> m.equal_range(<span style="color:#ae81ff">5</span>); <span style="color:#75715e">// c++17 结构化绑定
</span></span></span></code></pre></div><h3 id="设置entry_point">设置entry_point</h3>
<p>C程序允许设定一个entry_point作为启动函数，而不是main。</p>
<p>linux + gcc 下的一个简单的C程序设置入口函数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">my_main</span>(){
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;my_main&#34;</span>);
</span></span><span style="display:flex;"><span>    exit(<span style="color:#ae81ff">0</span>);<span style="color:#75715e">//此处必须有此代码，否则会segment fault，因为之后要进行堆空间分配
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	printf(<span style="color:#e6db74">&#34;main&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>gcc -e my_main test.c
</span></span></code></pre></div><h3 id="embedded-pointer">embedded pointer</h3>
<p>嵌入式指针，指在构建链表的时候可以使用union，将数据和指针共用内存。节省了一个指针的空间。概念图如下。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>---------------------
</span></span><span style="display:flex;"><span>|next  | data       |
</span></span><span style="display:flex;"><span>---------------------
</span></span><span style="display:flex;"><span>---------------------
</span></span><span style="display:flex;"><span>|next  | data       |
</span></span><span style="display:flex;"><span>---------------------
</span></span><span style="display:flex;"><span>---------------------
</span></span><span style="display:flex;"><span>|      data         |
</span></span><span style="display:flex;"><span>---------------------
</span></span></code></pre></div><h3 id="trivial类型和standard-layout">Trivial类型和Standard Layout</h3>
<p>原来被叫做POD（Plain Old Data），意指可以完全和C兼容的类型。POD类型被广泛应用于C++语言的底层编程以及与其他语言进行交互时的数据传输。例如，在使用二进制流进行数据传输时，可以将POD类型直接作为字节流传输，无需进行任何转换操作。</p>
<p>C++11之后，POD这个概念被更加严格地划分到两个概念，即Trivial和Standard Layout。Trivial是指满足一些条件（比如有默认构造函数等）的类，而Standard Layout则是指满足一些布局要求的类。</p>
<p><strong>Trivial</strong></p>
<p>如果一个类满足以下条件，则该类被认为是“Trivial”：</p>
<ol>
<li>它有一个非删除、非私有的默认构造函数，或者是一个使用 =default 标记的<strong>默认构造函数</strong>。</li>
<li>它有一个非删除、非私有的复制构造函数，或者是一个使用 =default 标记的<strong>默认复制构造函数</strong>。</li>
<li>它有一个非删除、非私有的移动构造函数，或者是一个使用 =default 标记的<strong>默认移动构造函数</strong>。</li>
<li>它有一个非删除、非私有的复制赋值运算符函数，或者是一个使用 =default 标记的<strong>默认复制赋值运算符函数</strong>。</li>
<li>它有一个非删除、非私有的移动赋值运算符函数，或者是一个使用 =default 标记的<strong>默认移动赋值运算符函数</strong>。</li>
<li>它有一个非删除的、公开且没有参数的析构函数，或者是一个使用 =default 标记的<strong>默认析构函数</strong>。</li>
</ol>
<p>如果一个类同时满足以上所有条件，则可以将其认为是“平凡的”。对于平凡的类，编译器可以采用一些优化手段，例如直接调用 memcpy() 和 memmove() 来进行复制和移动操作。</p>
<p><strong>Standard Layout</strong></p>
<p>如果一个类是标准布局（Standard Layout），那么这个类可以保证在不同编译器、不同操作系统下，它的<strong>内存布局</strong>是相同的。同时，标准布局类还能够更好地支持C和C++之间的互操作。</p>
<p>一个类被认为是标准布局，需要满足以下要求：</p>
<ol>
<li>所有非静态数据成员拥有相同的访问权限（public、protected、private）。</li>
<li>所有非静态数据成员在类中被声明的顺序就是它们在内存中出现的顺序。</li>
<li>类中没有任何虚函数或虚基类。</li>
<li>没有任何成员的类型与类本身相同（递归定义）。</li>
<li>所有基类都出现在派生类的最开始位置，且派生类中只包含非静态数据成员和零个或一个虚函数。</li>
</ol>
<h3 id="返回值优化">返回值优化</h3>
<p>考虑返回对象，避免拷贝构造，提升性能。<strong>在返回值确定时</strong>，编译器会对返回值进行优化，避免额外的拷贝。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">C</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    C() { std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;C::C()&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">~</span>C() { std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;C::~C()&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    C(<span style="color:#66d9ef">const</span> C <span style="color:#f92672">&amp;</span>) { std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;C::C(const C&amp;)&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    C(C <span style="color:#f92672">&amp;</span>) { std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;C::C(C&amp;)&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    C(C <span style="color:#f92672">&amp;&amp;</span>) <span style="color:#66d9ef">noexcept</span> { std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;C::C(C&amp;&amp;)&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    C <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> C <span style="color:#f92672">&amp;</span>) {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;C::operator=(const C&amp;)&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    C <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(C <span style="color:#f92672">&amp;&amp;</span>) {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;C::operator=(C&amp;&amp;)&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 无命名的，直接在指定位置构造
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>C <span style="color:#a6e22e">nrvo</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> C();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 有名字的，看情况优化，以下可预测的是同无命名的情况相同。正常会调用移动构造（优先）和拷贝构造。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>C <span style="color:#a6e22e">rvo</span>() {
</span></span><span style="display:flex;"><span>    C c;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> c;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span><span style="color:#75715e">//    C c = nrvo(); /*C::C() C::~C()*/
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    C c2 <span style="color:#f92672">=</span> rvo();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *  C::C()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        C::C(C&amp;&amp;)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        C::~C()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        C::~C()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="auto">auto</h3>
<p><strong>局限性</strong></p>
<p>auto自动推断无法知道何时要加引用。</p>
<p>在右边为const时，auto会推断出const。</p>
<p>在右边为&amp;或&amp;&amp;时，auto不会主动推断任何引用，会默认为值类型，会进行额外拷贝，因此需要额外注意引用符号的添加。</p>
<p>相当于模板匹配</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;&amp;</span> a <span style="color:#f92672">=</span>expr;
</span></span><span style="display:flex;"><span><span style="color:#75715e">//==
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> func(<span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;&amp;</span>);
</span></span></code></pre></div><p><strong>破解局限性</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">decltype</span>(<span style="color:#66d9ef">auto</span>) a <span style="color:#f92672">=</span> anyRef;
</span></span></code></pre></div><p><strong>模板自动推导</strong></p>
<p>从C++17开始可以自动推导模板参数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>array a <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>}; <span style="color:#75715e">// c++17开始
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>array<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,<span style="color:#ae81ff">3</span><span style="color:#f92672">&gt;</span> a <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>}; <span style="color:#75715e">// c++11必须这样
</span></span></span></code></pre></div><h3 id="stdbegin-end">std::begin end</h3>
<p>对于裸数组和容器，会返回它们的迭代器。</p>
<p>对于容器，和容器.begin end相同。</p>
<h3 id="通用初始化">通用初始化</h3>
<p>C++98只能对数组这样做<code>int arr[]={1,2,3};</code>。</p>
<p>C++11起，允许在创建<strong>任意对象</strong>时以逗号分隔的值序列的形式进行初始化<code>{1,2,3}</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// 调用构造函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> a{<span style="color:#ae81ff">1</span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a{}; <span style="color:#75715e">// POD类型 memreset为0 a=0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>string s{}; <span style="color:#75715e">// 默认构造
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>string s{<span style="color:#e6db74">&#34;Hello&#34;</span>}; <span style="color:#75715e">// const char* 构造
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">M</span>{}; <span style="color:#75715e">// POD类型 memreset为0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 构造后类型隐式转换
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> {};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>};
</span></span></code></pre></div><p>注意，在类型隐式转换时需要注意explicit的声明：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Point</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">explicit</span> Point(<span style="color:#66d9ef">double</span> x, <span style="color:#66d9ef">double</span> y) <span style="color:#f92672">:</span> x(x), y(y) {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Point(<span style="color:#66d9ef">double</span> x) <span style="color:#f92672">:</span> x(x), y(<span style="color:#ae81ff">0</span>) {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> x;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> y;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    Point p11 <span style="color:#f92672">=</span> {<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>}; <span style="color:#75715e">// 不可以, 因为声明了explicit, iniliazer_list不会被隐式转换为Point
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Point p12 <span style="color:#f92672">=</span> {<span style="color:#ae81ff">5</span>};    <span style="color:#75715e">// 可以, 因为没有声明explicit, iniliazer_list会被隐式转换为Point
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    Point p21{<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>};    <span style="color:#75715e">// 可以, 直接调用构造函数不受explicit影响
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Point p21{<span style="color:#ae81ff">5</span>};
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Point<span style="color:#f92672">&gt;</span> points1{{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>}, {<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>}}; <span style="color:#75715e">//同p11
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Point<span style="color:#f92672">&gt;</span> points2{{<span style="color:#ae81ff">1</span>}, {<span style="color:#ae81ff">3</span>}};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>std::initializer_list是一个容器用于支持这种语法传递。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Example</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 使用initializer_list将数组参数初始化转移到数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Example(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b, std<span style="color:#f92672">::</span>initializer_list<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> c) <span style="color:#f92672">:</span> m_a(a), m_b(b), m_c(c) {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> m_a;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> m_b;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> m_c;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    Example ex(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, {<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>});
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="字面量后缀">字面量后缀</h3>
<p>与<code>1.0f</code>的后缀<code>f</code>相似，用户可以自定义字面量的后缀。</p>
<p>与系统提供的不同，自己定义的需要加下划线。用户自定义的后缀和系统后缀一样，都可以用于静态初始化。</p>
<p>类型也是有限制的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">char</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">long</span> <span style="color:#66d9ef">double</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">char</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">*</span>, size_t
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">wchar_t</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">*</span>, size_t
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">char16_t</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">*</span>, size_t
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">char32_t</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">*</span>, size_t
</span></span></code></pre></div><p>例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">operator</span> <span style="color:#e6db74">&#34;&#34;</span>_cm(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> a) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> a;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">operator</span> <span style="color:#e6db74">&#34;&#34;</span>_m(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> a) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> a <span style="color:#f92672">*</span> <span style="color:#ae81ff">100</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>_cm <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>_m;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> a;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="stdbitset">std::bitset</h3>
<p>bitset 是一种容器类，用于存储二进制位信息。它可以内置数组的形式存储和访问一系列二进制位。</p>
<p>bitset可以用字符串初始化，并且自定义谁是0；还可以转换成数值和String。</p>
<p>注意：</p>
<ul>
<li>
<p>在初始化时，必须指定长度，若长度小于初始化的长度，则在左边填0；若实际长度超出初始化长度则只取实际左边的部分。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>bitset<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">8</span><span style="color:#f92672">&gt;</span> b(<span style="color:#e6db74">&#34;1011&#34;</span>); <span style="color:#75715e">//库理解为大端序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//内部实际存放：00001011 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//对应的index 7 6 5 4 3 2 1 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>bitset<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">8</span><span style="color:#f92672">&gt;</span> b2(<span style="color:#e6db74">&#34;1111110000&#34;</span>); <span style="color:#75715e">//库理解为大端序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//内部实际存放：11111100 
</span></span></span></code></pre></div></li>
<li>
<p>在取某个值的时候，0是指最低位。在以上例子中<code>b[0]</code>是1。</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bitset&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cassert&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstddef&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">typedef</span> std<span style="color:#f92672">::</span>size_t length_t, position_t; <span style="color:#75715e">// the hints
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// constructors:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">constexpr</span> std<span style="color:#f92672">::</span>bitset<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">4</span><span style="color:#f92672">&gt;</span> b1;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constexpr</span> std<span style="color:#f92672">::</span>bitset<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">4</span><span style="color:#f92672">&gt;</span> b2{<span style="color:#ae81ff">0xA</span>}; <span style="color:#75715e">// == 0B1010
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>bitset<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">4</span><span style="color:#f92672">&gt;</span> b3{<span style="color:#e6db74">&#34;0011&#34;</span>}; <span style="color:#75715e">// can also be constexpr since C++23
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>bitset<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">8</span><span style="color:#f92672">&gt;</span> b4{<span style="color:#e6db74">&#34;ABBA&#34;</span>, length_t(<span style="color:#ae81ff">4</span>), <span style="color:#75715e">/*0:*/</span><span style="color:#e6db74">&#39;A&#39;</span>, <span style="color:#75715e">/*1:*/</span><span style="color:#e6db74">&#39;B&#39;</span>}; <span style="color:#75715e">// == 0B0000&#39;0110
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// bitset supports bitwise operations:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    b3 <span style="color:#f92672">|=</span> <span style="color:#ae81ff">0b0100</span>; assert(b3 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0b0111</span>);
</span></span><span style="display:flex;"><span>    b3 <span style="color:#f92672">&amp;=</span> <span style="color:#ae81ff">0b0011</span>; assert(b3 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0b0011</span>);
</span></span><span style="display:flex;"><span>    b3 <span style="color:#f92672">^=</span> std<span style="color:#f92672">::</span>bitset<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">4</span><span style="color:#f92672">&gt;</span>{<span style="color:#ae81ff">0b1100</span>}; assert(b3 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0b1111</span>);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// operations on the whole set:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    b3.reset(); assert(b3 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    b3.set(); assert(b3 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0b1111</span>);
</span></span><span style="display:flex;"><span>    assert(b3.all() <span style="color:#f92672">&amp;&amp;</span> b3.any() <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>b3.none());
</span></span><span style="display:flex;"><span>    b3.flip(); assert(b3 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// operations on individual bits:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    b3.set(position_t(<span style="color:#ae81ff">1</span>), true); assert(b3 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0b0010</span>);
</span></span><span style="display:flex;"><span>    b3.set(position_t(<span style="color:#ae81ff">1</span>), false); assert(b3 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    b3.flip(position_t(<span style="color:#ae81ff">2</span>)); assert(b3 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0b0100</span>);
</span></span><span style="display:flex;"><span>    b3.reset(position_t(<span style="color:#ae81ff">2</span>)); assert(b3 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// subscript operator[] is supported:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    b3[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> true; assert(true <span style="color:#f92672">==</span> b3[<span style="color:#ae81ff">2</span>]);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// other operations:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    assert(b3.count() <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    assert(b3.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>    assert(b3.to_ullong() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0b0100ULL</span>);
</span></span><span style="display:flex;"><span>    assert(b3.to_string() <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;0100&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="static_assert">static_assert</h3>
<p>对const量进行假设，在编译期进行检查。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> rand();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static_assert</span>(a <span style="color:#f92672">==</span> <span style="color:#ae81ff">4</span>, <span style="color:#e6db74">&#34;a is not 4&#34;</span>); <span style="color:#75715e">// 错误Static_assert expression is not an integral constant expression
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static_assert</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">4</span>, <span style="color:#e6db74">&#34;int is not 4 bytes&#34;</span>);
</span></span></code></pre></div><h3 id="enum-class">enum class</h3>
<p>和整数没有转换，具有独立作用域。</p>
<p><code>enum class EnumName : underlying_type { enumerator_list };</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Color</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">uint8_t</span> {
</span></span><span style="display:flex;"><span>    RED <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>    GREEN <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>    BLUE <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    Color c1 <span style="color:#f92672">=</span> Color<span style="color:#f92672">::</span>RED;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//Color c2 = 0; //错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Color c3 <span style="color:#f92672">=</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>Color<span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">0</span>); <span style="color:#75715e">//可以
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h3 id="stdchrono">std::chrono</h3>
<p>提供时钟，时间点和持续时间。</p>
<p>时钟有系统时钟和单调时钟。</p>
<p><code>std::chrono::system_clock</code>表示的是系统级别的时钟，它的时钟周期由系统决定。</p>
<p><code>std::chrono::steady_clock</code>表示的是一个单调时钟（monotonic clock），它的时钟周期不会受到系统时间调整（例如闰秒、时区变更等）的影响，且保证不会出现时间倒流的情况。因此，<code>std::chrono::steady_clock</code>常用于计算时间间隔、计时等需要较高精度的任务。</p>
<p>注意，<code>std::chrono::steady_clock</code>不是绝对时间，其原点是未指定的，不能用于表示日期和时间。而 <code>std::chrono::system_clock</code>则可以被用于表示日期和时间，但其不保证单调性。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;chrono&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 获取当前系统时钟上的时间点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> now <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>chrono<span style="color:#f92672">::</span>system_clock<span style="color:#f92672">::</span>now();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 将时间点转换为 time_t 类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> now_time_t <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>chrono<span style="color:#f92672">::</span>system_clock<span style="color:#f92672">::</span>to_time_t(now);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 输出当前时间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Current time: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>ctime(<span style="color:#f92672">&amp;</span>now_time_t);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 计算程序运行时间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> start <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>chrono<span style="color:#f92672">::</span>steady_clock<span style="color:#f92672">::</span>now();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1000000</span>; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// do something
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> end <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>chrono<span style="color:#f92672">::</span>steady_clock<span style="color:#f92672">::</span>now();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> elapsed <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>chrono<span style="color:#f92672">::</span>duration_cast<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>chrono<span style="color:#f92672">::</span>microseconds<span style="color:#f92672">&gt;</span>(end <span style="color:#f92672">-</span> start);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Elapsed time: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> elapsed.count() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; microseconds.&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="stdrandom">std::random</h3>
<p>std随机数生成可以分为两个部分：引擎和分布器。引擎负责生成随机位序列，而分布器负责将这些随机位转换成各种不同的分布形式，从而实现不同类型随机数的生成。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;random&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>mt19937_64 rng(std<span style="color:#f92672">::</span>random_device{}());        <span style="color:#75715e">// 随机数引擎
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>ranlux48 rng2(std<span style="color:#f92672">::</span>random_device{}());         <span style="color:#75715e">// 随机数引擎
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>uniform_int_distribution<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> dist(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">100</span>);    <span style="color:#75715e">// 随机数分布器-均匀分布
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>normal_distribution<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;</span> dist2(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>);       <span style="color:#75715e">// 随机数分布器-正态分布
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> dist(rng); <span style="color:#75715e">// 生成随机数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="stdany">std::any</h3>
<p>C++17起存在。</p>
<p><code>std::any</code>可以<strong>存储任意类型的值</strong>。<code>std::any</code>的使用需要注意类型安全，如果在调用 <code>std::any_cast</code>时传入了错误的类型，会抛出一个 <code>std::bad_any_cast</code>异常。</p>
<ul>
<li>作为一种替代void*的方案。</li>
<li>作为任意容器如<code>std::vector&lt;std::any&gt;</code></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>any a <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// 声明对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>any_cast<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(a) <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span>(a.type() <span style="color:#f92672">==</span> <span style="color:#66d9ef">typeid</span>(<span style="color:#66d9ef">int</span>)){
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;int&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="stdoptional">std::optional</h3>
<p>C++17起存在。它是一种可选值类型，表示一个值可能存在，也可能不存在的情况。</p>
<p><code>std::optional</code>与<code>std::any</code>相比，语义更加明确，而且使用值的时候不必再进行类型判断。</p>
<p>optional和对象存放在一起，都放在栈上或堆上。因此在大数据情况下会发送拷贝。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>optional<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> divide(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (b <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>nullopt; <span style="color:#75715e">// 没有值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> a <span style="color:#f92672">/</span> b;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>optional<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> result <span style="color:#f92672">=</span> divide(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (result.has_value()) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="stdvarient">std::varient</h3>
<p>类似于<code>union</code>，<code>std::variant</code>可以存储多个类型的值，但只有<strong>其中一种类型的值是有效的</strong>，即只有一种类型的值处于“激活”状态。可以通过 <code>std::variant</code> 提供的 API 显式地切换各种类型之间的值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>variant<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;</span> v <span style="color:#f92672">=</span> <span style="color:#ae81ff">2.0</span>;  <span style="color:#75715e">// 定义一个 variant 对象, 若初始化时不赋值则初始化第0个的类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (v.index() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {               <span style="color:#75715e">// 判断当前存储的值类型，并进行对应操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>get<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(v);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;stored int value: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (v.index() <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> d <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>get<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;</span>(v);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;stored double value: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> d <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">auto</span> ptr <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>get_if<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(<span style="color:#f92672">&amp;</span>v)) {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;stored int value: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>ptr <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span><span style="color:#75715e">/***********类似实现, 适用于POD***********/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">FloatIntChar</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">enum</span> {
</span></span><span style="display:flex;"><span>        Float,
</span></span><span style="display:flex;"><span>        Int,
</span></span><span style="display:flex;"><span>        Char
</span></span><span style="display:flex;"><span>    } type;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">union</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">float</span> f;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">char</span> c;
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>FloatIntChar fic;
</span></span><span style="display:flex;"><span>fic.type <span style="color:#f92672">=</span> FloatIntChar<span style="color:#f92672">::</span>Float;
</span></span><span style="display:flex;"><span>fic.f <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0f</span>;
</span></span></code></pre></div><table>
<thead>
<tr>
<th style="text-align:left">项目</th>
<th><code>any</code></th>
<th><code>optional</code></th>
<th><code>variant</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">默认空构造</td>
<td>是</td>
<td>是</td>
<td>否，初始化第0个对象类型</td>
</tr>
<tr>
<td style="text-align:left">存储内容</td>
<td>任意类型的值</td>
<td><strong>指定类型</strong>的值或未初始化状态</td>
<td>多种可能类型的值</td>
</tr>
<tr>
<td style="text-align:left">值检查</td>
<td>has_value</td>
<td>has_value</td>
<td>has_value</td>
</tr>
<tr>
<td style="text-align:left">值获取</td>
<td><code>std::any_cast&lt;&gt;</code></td>
<td><code>*</code> 或 <code>-&gt;</code> 运算符</td>
<td>std::get，get_if</td>
</tr>
<tr>
<td style="text-align:left">使用场景</td>
<td>不确定值类型；需要动态存储和访问不同类型的值</td>
<td>可能为空的类型；仅在需要时才存储和访问值</td>
<td>需要处理多种数据类型的值；类型已知但可能变化</td>
</tr>
</tbody>
</table>
<h3 id="stderror_code-error_condition">std::error_code error_condition</h3>
<p>标准库提供了错误码支持，给不能使用异常的情况提供支持。</p>
<p>error_code是平台相关的错误，error_condition是平台独立的错误（通常由用户提供），它们内置了很多错误码，可以直接使用。错误库的解释如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>errc              <span style="color:#f92672">-&gt;</span> std<span style="color:#f92672">::</span>posix_error_code
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>error_code        <span style="color:#f92672">-&gt;</span> std<span style="color:#f92672">::</span>platform_dependent_error
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>error_condition   <span style="color:#f92672">-&gt;</span> std<span style="color:#f92672">::</span>platform_independent_error
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>error_category    <span style="color:#f92672">-&gt;</span> std<span style="color:#f92672">::</span>error_domain<span style="color:#f92672">/</span>utility<span style="color:#f92672">/</span>mapper
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>system_category   <span style="color:#f92672">-&gt;</span> std<span style="color:#f92672">::</span>platform_dependent_error_domain
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>generic_category  <span style="color:#f92672">-&gt;</span> std<span style="color:#f92672">::</span>platform_independent_error_domain
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>future_errc       <span style="color:#f92672">-&gt;</span> std<span style="color:#f92672">::</span>future_error_code
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>future_category   <span style="color:#f92672">-&gt;</span> std<span style="color:#f92672">::</span>future_error_domain
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>io_errc           <span style="color:#f92672">-&gt;</span> std<span style="color:#f92672">::</span>iostream_error_code
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>iostream_category <span style="color:#f92672">-&gt;</span> std<span style="color:#f92672">::</span>iostream_error_domain
</span></span></code></pre></div><p>简单使用例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>error_code ec <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>make_error_code(std<span style="color:#f92672">::</span>errc<span style="color:#f92672">::</span>no_such_file_or_directory);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Error message: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> ec.message() <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Error category: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> ec.category().name() <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Error code: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> ec.value() <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>error_condition ec2 <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>make_error_condition(std<span style="color:#f92672">::</span>errc<span style="color:#f92672">::</span>no_such_file_or_directory);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Error message: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> ec2.message() <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Error category: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> ec2.category().name() <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Error code: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> ec2.value() <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span></code></pre></div><p>std::error_code可以和varient配合，解决了optional返回空，但是不知道什么错误的场景。</p>
<p>std::error_code和std::error_condition都继承自std::error_category，可以自定义error类型实现向std::error_code和std::error_condition的转换。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;system_error&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;variant&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;any&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyErrorType</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    success,
</span></span><span style="display:flex;"><span>    error1
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">my_error_category</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> std<span style="color:#f92672">::</span>error_category {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Return a short descriptive name for the category, 继承自基类std::error_category
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>name() <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">noexcept</span> <span style="color:#66d9ef">override</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;my_error_category&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Return what each enum means in text, 继承自基类std::error_category
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>string message(<span style="color:#66d9ef">int</span> i) <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">override</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">switch</span> (i) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(MyErrorType<span style="color:#f92672">::</span>success)<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;success&#34;</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(MyErrorType<span style="color:#f92672">::</span>error1)<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;error1&#34;</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;Unknown error&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 转换成std::error_condition, 继承自基类std::error_category
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>error_condition default_error_condition(<span style="color:#66d9ef">int</span> i) <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">noexcept</span> <span style="color:#66d9ef">override</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">switch</span> (i) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(MyErrorType<span style="color:#f92672">::</span>success)<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> {};
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(MyErrorType<span style="color:#f92672">::</span>error1)<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> make_error_condition(std<span style="color:#f92672">::</span>errc<span style="color:#f92672">::</span>invalid_argument);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>error_condition(i, <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>error_code make_error_code(MyErrorType e) <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">noexcept</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>error_code(<span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(e), <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>error_condition e <span style="color:#f92672">=</span> my_error_category().default_error_condition(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> e.message() <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;              <span style="color:#75715e">//Invalid argument
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> e.category().name() <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;      <span style="color:#75715e">//generic
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> e.value() <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;                <span style="color:#75715e">//22
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>error_code ec <span style="color:#f92672">=</span> my_error_category().make_error_code(MyErrorType<span style="color:#f92672">::</span>error1);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> ec.message() <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;             <span style="color:#75715e">//error1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> ec.category().name() <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;     <span style="color:#75715e">//my_error_category
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> ec.value() <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;               <span style="color:#75715e">//1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h3 id="视图">视图</h3>
<p>视图（View）通常指一些不拥有自己的元素、而是引用其他容器中已有元素的对象。它们能够提供对数据的不同方式的访问或切片。</p>
<p>容器一般会管理内容的生命周期，而视图<strong>不会</strong>，不拥有内容也不能修改内容，因此需要自行保证内容是可以合法访问的。</p>
<p><strong>std::string_view C++17</strong></p>
<p>无需进行string的统一构造或移动。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>string gen(std<span style="color:#f92672">::</span>string_view str) {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>string str2 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hi &#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> str2 <span style="color:#f92672">+</span> str.data();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> gen(<span style="color:#e6db74">&#34;Jack&#34;</span>) <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>string str <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Bob&#34;</span>;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> gen(str) <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="stdfunction">std::function</h3>
<p>函数包装器，让不同实现的函数统一类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>function<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>(<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>)<span style="color:#f92672">&gt;</span> add <span style="color:#f92672">=</span> [](<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b) { <span style="color:#66d9ef">return</span> a <span style="color:#f92672">+</span> b; };
</span></span><span style="display:flex;"><span>add(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>)
</span></span></code></pre></div><p>std::function/lambda表达式用于取代std::bind。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">sum</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> a <span style="color:#f92672">+</span> b;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> new_sum <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>bind(sum, <span style="color:#ae81ff">1</span>, std<span style="color:#f92672">::</span>placeholders<span style="color:#f92672">::</span>_1);
</span></span></code></pre></div><h3 id="currying柯里化">Currying（柯里化）</h3>
<p>Currying（柯里化）是一种函数式编程技术，它可以将接受多个参数的函数转换成接受单一参数（最初函数的第一个参数）的函数序列。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">sum</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b, <span style="color:#66d9ef">int</span> c) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> a <span style="color:#f92672">+</span> b <span style="color:#f92672">+</span> c;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> sum(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> curry_sum <span style="color:#f92672">=</span> [](<span style="color:#66d9ef">int</span> a) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> [a](<span style="color:#66d9ef">int</span> b) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> [a, b](<span style="color:#66d9ef">int</span> c) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">sum</span>(a, b, c);
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> curry_sum(<span style="color:#ae81ff">1</span>)(<span style="color:#ae81ff">2</span>)(<span style="color:#ae81ff">3</span>);
</span></span></code></pre></div><h3 id="if-constexpr">if constexpr</h3>
<p>C++17。constexpr表示编译期常量，简化了对SFINAE的使用。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;type_traits&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> Print(<span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> data) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">constexpr</span> (std<span style="color:#f92672">::</span>is_integral_v<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>) { <span style="color:#75715e">//在编译期就可以判断了! 不需要额外去做模板去匹配
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Integer: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> data <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">constexpr</span> (std<span style="color:#f92672">::</span>is_floating_point_v<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>) {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Float: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> data <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">static_assert</span>(std<span style="color:#f92672">::</span>is_same_v<span style="color:#f92672">&lt;</span>T, <span style="color:#66d9ef">void</span><span style="color:#f92672">&gt;</span>, <span style="color:#e6db74">&#34;Unsupported type!&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> f <span style="color:#f92672">=</span> <span style="color:#ae81ff">3.14</span>;
</span></span><span style="display:flex;"><span>    Print(i); <span style="color:#75715e">// 输出 &#34;Integer: 42&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Print(f); <span style="color:#75715e">// 输出 &#34;Float: 3.14&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// Print(&#34;hello&#34;); // 编译错误，不支持字符串类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="多线程">多线程</h2>
<p>C++<strong>标准库</strong>没有提供进程相关的支持，提供的都是线程相关的。</p>
<h3 id="多线程库">多线程库</h3>
<h4 id="stdthread">std::thread</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;thread&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">my_func</span>() {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Hello from thread&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">my_func_args</span>(<span style="color:#66d9ef">int</span> a) {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Hello from thread&#34;</span> <span style="color:#f92672">&lt;&lt;</span> a <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> t(my_func);             <span style="color:#75715e">//函数指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> t2([]() {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Hello from thread2&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    });                                 <span style="color:#75715e">//lambda表达式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> t3(my_func_args, <span style="color:#ae81ff">3</span>);    <span style="color:#75715e">//带参数的函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 必须进行join或者detach 否则会抛出异常
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    t.join();
</span></span><span style="display:flex;"><span>    t2.join();
</span></span><span style="display:flex;"><span>    t3.join();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>join()和detach的作用和区别</p>
<p><code>join()</code>和<code>detach()</code>都是<code>std::thread</code>类的成员函数，用于在创建新线程后<strong>控制线程的运行状态和资源回收</strong>。</p>
<p><code>join</code>待新线程执行结束，并阻塞当前线程，直到新线程执行结束才可以继续执行当前线程。</p>
<p><code>detach</code>将新线程和当前线程分离，新线程在后台执行，当前线程（一般是主线程）不等待新线程执行结束就会继续执行下去。<strong>主线程退出后，新线程直接结束了</strong>。</p>
<p><code>joinable()</code>是<code>std::thread</code>类的成员函数，用于判断当前线程是否可被join或detach。一个线程不可以被两次join或detach。</p>
<h4 id="stdfuture库">std::future库</h4>
<p>类似于Javascript的promise，用于方便的执行异步任务，相对于thread创建线程更加简洁。内部实现多是线程池。</p>
<p><code>std::future</code>的实现原理是两个关键组件：Promise和Future。</p>
<ul>
<li>Promise：表示异步任务的提供者，负责生成结果并且在完成时将结果传递给Future对象。</li>
<li>Future：表示异步任务的消费者，用于等待 Promise 对象产生的结果。</li>
</ul>
<p><code>std::promise</code> 类就是Promise的具体实现，而<code>std::future</code>则是Future的具体实现。</p>
<p>当通过 <code>std::async</code> 启动一个新的异步任务时，它会创建一个 <code>std::promise</code> 对象，并返回一个与之关联的 <code>std::future</code> 对象。异步任务在执行过程中可以使用 <code>std::promise</code> 对象来设置异步操作的结果或异常信息，并由 <code>std::future</code> 对象来获取异步操作的结果或异常信息。</p>
<p>常用的<code>std::future</code>方法包括以下几个：</p>
<ul>
<li><code>wait()</code>：等待异步操作完成。</li>
<li><code>get()</code>：获取异步操作的结果（如果操作还没有完成则会阻塞）。</li>
<li><code>get_or_default(T&amp;&amp; default_value)</code>：获取异步操作的结果，如果操作还没有完成则返回默认值。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">task</span>(std<span style="color:#f92672">::</span>promise<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string<span style="color:#f92672">&gt;</span> promise) {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>string result <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Task completed.&#34;</span>;
</span></span><span style="display:flex;"><span>    promise.set_value(result);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>promise<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string<span style="color:#f92672">&gt;</span> promise; <span style="color:#75715e">// 获取生产者
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>future<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string<span style="color:#f92672">&gt;</span> future <span style="color:#f92672">=</span> promise.get_future(); <span style="color:#75715e">// 获取消费者对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 启动异步任务
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>async(std<span style="color:#f92672">::</span>launch<span style="color:#f92672">::</span>async, task, std<span style="color:#f92672">::</span>move(promise));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 输出异步操作结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> future.get() <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="互斥操作">互斥操作</h3>
<h4 id="基础锁stdmutex">基础锁：std::mutex</h4>
<p><code>std::mutex</code>是一个裸的互斥量，用于实现互斥锁机制。有以下成员函数：</p>
<ul>
<li><code>lock()</code>：获取互斥锁，如果当前锁已经被其他线程占用，则当前线程会阻塞等待锁的释放</li>
<li><code>unlock()</code>：释放互斥锁</li>
<li><code>try_lock()</code>：尝试获取互斥锁，如果当前锁已经被其他线程占用，则该函数立即返回 false，而不会阻塞</li>
</ul>
<p>不推荐直接使用裸的互斥锁，因为加锁解锁都需要手动进行，容易出错。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>mutex g_mutex;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> g_counter <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">increment_counter</span>() {
</span></span><span style="display:flex;"><span>    g_mutex.lock(); <span style="color:#75715e">// 获取互斥锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">++</span>g_counter;    <span style="color:#75715e">// 修改共享资源
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    g_mutex.unlock(); <span style="color:#75715e">// 释放互斥锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h4 id="读写锁stdunique_lock--stdshared_lock">读写锁：std::unique_lock / std::shared_lock</h4>
<p><code>std::unique_lock/std::shared_lock</code>与<code>std::mutex</code>配合使用，实现读/写锁机制。还可以与其他基础锁配合。</p>
<p><code>std::unique_lock</code>具有独占性，无法独占变量就阻塞。</p>
<p><code>std::shared_lock</code>不具有独占性，只是占用锁，防止<code>std::unique_lock</code>获取锁，以阻塞他。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>shared_mutex g_mutex;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> g_counter <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">increment_counter</span>() {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>unique_lock<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>shared_mutex<span style="color:#f92672">&gt;</span> lock(g_mutex); <span style="color:#75715e">// 获取共享锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">++</span>g_counter; <span style="color:#75715e">// 修改共享资源
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    lock.unlock(); <span style="color:#75715e">// 释放共享锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">read_counter</span>() {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>shared_lock<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>shared_mutex<span style="color:#f92672">&gt;</span> lock(g_mutex); <span style="color:#75715e">// 获取共享锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Counter value: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> g_counter <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl; <span style="color:#75715e">// 读取共享资源
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h4 id="封装的互斥锁stdlock_guard">封装的互斥锁：std::lock_guard</h4>
<p>是一种RAII锁保护机制，它可以自动对互斥量进行加锁和解锁，避免了使用裸互斥锁的复杂。</p>
<p>在离开第一个作用域（<code>}</code>）时自动解锁。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>mutex g_mutex;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foo</span>(<span style="color:#66d9ef">int</span> id) {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>lock_guard<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>mutex<span style="color:#f92672">&gt;</span> lock(g_mutex);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Thread &#34;</span> <span style="color:#f92672">&lt;&lt;</span> id <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; start&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 执行一些需要互斥访问的操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Thread &#34;</span> <span style="color:#f92672">&lt;&lt;</span> id <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; end&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="stdatomic">std::atomic</h4>
<p>能够通过硬件支持或操作系统提供的原子指令来实现对共享变量的原子操作，从而避免了使用锁的开销和复杂性。</p>
<p>使用atomic显著快于使用加锁操作实现原子操作。</p>
<p><code>std::atomic</code>支持的操作包括：</p>
<ul>
<li>加法、减法、乘法、除法、按位与、按位或、按位异或等基本算术运算；</li>
<li>递增、递减、前后缀自增、前后缀自减等自增自减操作；</li>
<li>比较交换、交换值等操作；</li>
<li>支持所有内置的算术类型和指针类型。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>atomic<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> g_count(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foo</span>(<span style="color:#66d9ef">int</span> id) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10000</span>; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">++</span>g_count;
</span></span><span style="display:flex;"><span>        g_count.fetch_add(<span style="color:#ae81ff">1</span>, std<span style="color:#f92672">::</span>memory_order_relaxed);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>其中<code>std::memory_order_relaxed</code>代表内存序。内存序问题见<a href="#%E6%9C%BA%E5%99%A8%E6%89%A7%E8%A1%8C%E6%97%B6%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%BB%E5%86%99%E9%A1%BA%E5%BA%8F">下节</a>。atomic支持的内存序如下。</p>
<table>
<thead>
<tr>
<th>内存序</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>memory_order_relaxed</code></td>
<td>没有同步或顺序制约，仅对此操作要求原子性</td>
</tr>
<tr>
<td><code>memory_order_acquire</code></td>
<td>当前线程中读或写不能被重排到此加载前</td>
</tr>
<tr>
<td><code>memory_order_release</code></td>
<td>当前线程中的读或写不能被重排到此存储后</td>
</tr>
<tr>
<td><code>memory_order_acq_rel</code></td>
<td>结合 acquire 和 release 两种内存序的效果，在读取和修改操作中都具有同步效果。</td>
</tr>
<tr>
<td><code>memory_order_seq_cst</code></td>
<td>是最强的内存序。所有操作都按照序列顺序执行，且对其他线程的修改和访问都具有同步效果。</td>
</tr>
</tbody>
</table>
<h4 id="stdcondition_variable">std::condition_variable</h4>
<p>用于实现异步通知。</p>
<p><code>std::condition_variable</code>支持的操作包括：</p>
<ul>
<li>等待条件的发生：<code>wait()</code>、<code>wait_for()</code>等待一段时间、<code>wait_until()</code>等待至截至时间</li>
<li>通知等待线程：<code>notify_one()</code>、<code>notify_all()</code></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>mutex g_mutex;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>condition_variable g_cv;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> g_ready <span style="color:#f92672">=</span> false; <span style="color:#75715e">//此处g_ready是为了防止虚假唤醒
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">worker_thread</span>() {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>unique_lock<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>mutex<span style="color:#f92672">&gt;</span> lock(g_mutex);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 小心虚假唤醒 应当使用while
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>g_ready) {
</span></span><span style="display:flex;"><span>        g_cv.wait(lock); <span style="color:#75715e">// 等待条件变量被唤醒
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// g_cv.wait(lock, g_ready); //等价
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Worker thread is running!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> t(worker_thread);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 做一些计算... 比如文件读写 之后g_ready会为true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>lock_guard<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>mutex<span style="color:#f92672">&gt;</span> lock(g_mutex);
</span></span><span style="display:flex;"><span>        g_ready <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>        g_cv.notify_one(); <span style="color:#75715e">// 唤醒一个等待线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    t.join();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="thread_local关键字">thread_local关键字</h4>
<p>C++11。用于声明<strong>线程局部变量</strong>。与全局变量和局部变量不同，线程局部变量是每个线程独立拥有的变量，<strong>不同线程之间互不干扰</strong>。线程局部变量的生命周期与声明它的线程的生命周期一样长。每个线程都会拥有自己的变量实例，并且在线程结束时被自动销毁。</p>
<h3 id="机器执行时的内存读写顺序">机器执行时的内存读写顺序</h3>
<p>乱序执行问题</p>
<p>当CPU 遇到需要等待的指令时，它不会停下来等待这条指令执行完毕，而是会这时执行它后面还没有执行的指令。当这条指令被执行完毕后，CPU 再回过头去执行刚才因为等待这条指令而跳过的指令。</p>
<p>编译器和CPU都会进行乱序操作。</p>
<p><a href="https://preshing.com/20120515/memory-reordering-caught-in-the-act/">Memory Reordering Caught in the Act (preshing.com)</a></p>
<h2 id="智能指针">智能指针</h2>
<p>以下指针都是模板类，使用时传入类型和对应类型的指针，例如<code>std::shared_ptr&lt;int&gt; sp1(new int(42));</code>。</p>
<p><strong>unique_ptr</strong></p>
<p>它是一个用于管理动态分配对象的类模板。它的特点在于，它是独占式的，也就是说，同一时间只能有一个unique_ptr指向一个对象。当该unique_ptr被销毁时，它所拥有的对象也会被自动销毁。</p>
<p><strong>shared_ptr</strong></p>
<p>它也用于管理动态分配对象。与unique_ptr不同的是，多个shared_ptr可以指向同一个对象，且对象的引用计数会随之增加。只有当<strong>所有</strong>shared_ptr被销毁时，对象的引用计数才会降为0，才会被销毁。</p>
<p><strong>weak_ptr</strong></p>
<p>它可以与shared_ptr协同工作。当一个对象被一个shared_ptr管理时，有时我们需要一个<strong>非拥有者的观察者</strong>，使用weak_ptr可以实现这个功能。weak_ptr不会改变引用计数，也不会影响所观察的对象的生命周期。</p>
<p><strong>auto_ptr</strong>（已弃用）</p>
<p><code>auto_ptr</code> 类的主要特点是“所有权的转移”，也就是说当一个 <code>auto_ptr</code> 对象拥有资源时，其它的 <code>auto_ptr</code> 对象不能拥有相同的资源。这意味着，当一个 <code>auto_ptr</code> 对象被赋值给另一个 <code>auto_ptr</code> 对象时，<strong>原始对象将失去对资源的控制权</strong>。这种特性可能会导致一些意外的行为，因此，C++11标准推荐使用 <code>unique_ptr</code> 来代替 <code>auto_ptr</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;memory&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>auto_ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> ap1(<span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>(<span style="color:#ae81ff">42</span>)); <span style="color:#75715e">// 创建一个 int 对象，并用 auto_ptr 管理它
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>auto_ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> ap2;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    ap2 <span style="color:#f92672">=</span> ap1; <span style="color:#75715e">// 将 ap1 赋给 ap2，ap1 将失去对资源的所有权
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;ap2 指向的整数值为：&#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>ap2 <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ap1 已经失去了对资源的所有权，因此不需要手动释放内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>make_shared和make_unique（推荐使用）</strong></p>
<p><code>make_shared</code>和<code>make_unique</code>都是C++11提供的工厂函数，用于创建智能指针（<code>shared_ptr</code>和<code>unique_ptr</code>）。</p>
<p>好处如下：</p>
<ol>
<li>与直接使用<code>new</code>分配内存不同，工厂函数使用<strong>单个内存块来管理对象和控制块</strong>，将内存块和管理区放在一起，减少了堆内存分配的次数。</li>
<li>避免构造时出现异常，导致智能指针对象没有获得裸指针，从而导致内存泄漏。</li>
</ol>
<p>示例代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> p <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>make_shared<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">42</span>);
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> p <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>make_unique<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">42</span>);
</span></span></code></pre></div><p>特性：</p>
<ul>
<li>
<p>数组支持</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>unique_ptr<span style="color:#f92672">&lt;</span>T[]<span style="color:#f92672">&gt;</span> <span style="color:#75715e">//c++11
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>shared_ptr<span style="color:#f92672">&lt;</span>T[]<span style="color:#f92672">&gt;</span> <span style="color:#75715e">//c++17
</span></span></span></code></pre></div></li>
<li>
<p>自定义删除器，自定义删除器可以是函数指针、函数对象或lambda表达式。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;memory&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 函数指针, 也可以是lambda表达式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">deleter_func</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>ptr) {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;执行自定义删除器，释放内存&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">delete</span> ptr;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//仿函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">deleter</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">operator</span>()(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>ptr) <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;执行自定义删除器，释放内存&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">delete</span> ptr;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>p1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>(<span style="color:#ae81ff">42</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>p2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>(<span style="color:#ae81ff">42</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>p3 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>(<span style="color:#ae81ff">42</span>);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>)<span style="color:#f92672">&gt;</span> up1(p1, deleter_func);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, deleter<span style="color:#f92672">&gt;</span> up2(p2, deleter());
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, deleter<span style="color:#f92672">&gt;</span> up3(p3); <span style="color:#75715e">//简化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// auto p4 = std::make_unique&lt;int&gt;(42,deleter()); 工厂函数不支持
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
<li></li>
</ul>

  </div>

  <footer class="post-footer">
    

    

    
    
  </footer>
  
  <div class="comments">
  <div class="comments">



</div>
  </div>
</article>

  <div class="foot">
  
  &copy; 2019 - 2023 &#183;
  <a href="/"> YuYoung&#39;s Blog </a> &nbsp;&nbsp;
  <a href="#"><i class="fas fa-chevron-up"></i></a>
</div>
</body>
  <script src="/js/lazyload.min.js"></script>
<script>
  var lazyImage = new LazyLoad({container: document.getElementById('article')});
</script>



<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.slim.min.js" integrity="sha256-/SIrNqv8h6QGKDuNoLGA4iret+kyesCkHGzVUUV0shc=" crossorigin="anonymous"></script>
<script>
    (function() {
        var $toc = $('#TableOfContents');
        if ($toc.length > 0) {
            var $window = $(window);

            function onScroll(){
                var currentScroll = $window.scrollTop();
                var h = $('.post-text h1, .post-text h2, .post-text h3, .post-text h4, .post-text h5, .post-text h6');
                var id = "";
                h.each(function (i, e) {
                    e = $(e);
                    if (e.offset().top - 10 <= currentScroll) {
                        id = e.attr('id');
                    }
                });
                var active = $toc.find('a.active');
                if (active.length == 1 && active.eq(0).attr('href') == '#' + id) return true;

                active.each(function (i, e) {
                    $(e).removeClass('active').siblings('ul').hide();
                });
                $toc.find('a[href="#' + id + '"]').parentsUntil('#TableOfContents').each(function (i, e) {
                    $(e).children('a').addClass('active').siblings('ul').show();
                });
            }

            $window.on('scroll', onScroll);
            $(document).ready(function() {
                $toc.find('a').parent('li').find('ul').hide();
                onScroll();
                document.getElementsByClassName('post-toc')[0].style.display = '';
            });
        }
    })();
</script>


</html>
