<!DOCTYPE html>
<html lang="zh">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="generator" content="Hugo 0.111.3">
  <title> C&#43;&#43;小知识 | YuYoung&#39;s Blog </title>
  <meta name="description" content="YuYoung的博客">
  <link rel="stylesheet" href="https://yuyoung32.github.io/css/simpleness.css">
  <link rel="canonical" href="https://yuyoung32.github.io/post/c&#43;&#43;%E5%B0%8F%E7%9F%A5%E8%AF%86/">
  <link rel="alternate" type="application/rss+xml" href="" title="YuYoung&#39;s Blog">
  
  
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css" rel="stylesheet">
  
  
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6QCN1ZG6DB"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-6QCN1ZG6DB', { 'anonymize_ip': false });
}
</script>

  
</head>
<body class="container">
  <nav class="navigation">
  <div class="nav-left">
    
    <div class="nav-item nav-title">
      <a href="https://yuyoung32.github.io/"> YuYoung&#39;s Blog</a>
    </div>
    <div class="nav-item nav-menu">
      
      <a href="/"> Home</a>
      
      <a href="/about/"> About</a>
      
    </div>
  </div>
  <div class="nav-item nav-right fontawesome">
    
    
    <a href="https://github.com/YuYoung32" target="_blank">
      <i title="GitHub" class="fab fa-github"></i>
    </a>
    
    
    <a href="https://yuyoung32.github.io/index.xml" target="_blank">
      <i title="RSS" class="fas fa-rss"></i>
    </a>
    
  </div>
</nav>

  
<article class="post">
  <header class="post-header">
    <h1 style="text-align: center;" >C&#43;&#43;小知识</h1>
    <div class="post-metadata">
    
      <time datetime="2022-08-09T23:25:36&#43;08:00">August 09, 2022</time> &nbsp; 
    
    
    
    
    
    
      <i class="fas fa-folder"></i>
      
      <a href="/categories/c&#43;&#43;">c&#43;&#43;</a>
      &nbsp;
      
    
    </div>
  </header>

  
  <div class="post-toc">
    <div class="post-toc-title">-目录-</div>
    <nav id="TableOfContents">
  <ul>
    <li><a href="#左右值和左右值引用">左右值和左右值引用</a></li>
    <li><a href="#构造函数初始化列表">构造函数初始化列表</a></li>
    <li><a href="#重载">重载</a>
      <ul>
        <li><a href="#函数重载与默认参数">函数重载与默认参数</a></li>
      </ul>
    </li>
    <li><a href="#函数名称修饰">函数名称修饰</a></li>
    <li><a href="#模板">模板</a>
      <ul>
        <li><a href="#模板函数">模板函数</a></li>
        <li><a href="#显式具体化">显式具体化</a></li>
        <li><a href="#显式实例化">显式实例化</a></li>
        <li><a href="#重载解析">重载解析</a></li>
        <li><a href="#decltype-和-auto">decltype 和 auto</a></li>
        <li><a href="#模板类">模板类</a></li>
        <li><a href="#模板参数">模板参数</a></li>
      </ul>
    </li>
    <li><a href="#函数指针分析">函数指针分析</a></li>
    <li><a href="#仿函数">仿函数</a></li>
    <li><a href="#存储持续性和链接性">存储持续性和链接性</a></li>
    <li><a href="#虚函数和纯虚函数">虚函数和纯虚函数</a></li>
    <li><a href="#存储区">存储区</a></li>
    <li><a href="#成员函数const和mutable">成员函数const和mutable</a></li>
    <li><a href="#友元函数">友元函数</a></li>
    <li><a href="#多继承">多继承</a></li>
    <li><a href="#内存对齐">内存对齐</a></li>
    <li><a href="#类型转换">类型转换</a>
      <ul>
        <li><a href="#dynamic_cast">dynamic_cast</a></li>
        <li><a href="#static_cast">static_cast</a></li>
        <li><a href="#reinterpret_cast">reinterpret_cast</a></li>
        <li><a href="#const_cast">const_cast</a></li>
        <li><a href="#例子类之间的转换">例子：类之间的转换</a></li>
      </ul>
    </li>
    <li><a href="#黑科技">黑科技</a>
      <ul>
        <li><a href="#模板里的typename">模板里的typename</a></li>
        <li><a href="#typeid-打印类型名称">typeid 打印类型名称</a></li>
        <li><a href="#std算法库">std::算法库</a></li>
        <li><a href="#sfinae">SFINAE</a></li>
        <li><a href="#tuple">tuple</a></li>
        <li><a href="#bind">bind</a></li>
        <li><a href="#type-traits">type traits</a></li>
        <li><a href="#设置entry_point">设置entry_point</a></li>
        <li><a href="#embedded-pointer">embedded pointer</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
  

  <div class="post-text">
    <h2 id="左右值和左右值引用">左右值和左右值引用</h2>
<p><strong>左值：</strong> 可以取地址，有名字的，非临时的就是左值。</p>
<p><strong>右值：</strong> 不能取地址，没有名字的，临时的就是右值。</p>
<p><strong>左值引用：</strong> 相当于指针指向某个左值，取了左值的地址。就是说左值引用要求右边的值可以取地址，若不能取地址可以，像这样<code>const int&amp; a = 1;</code>实际是创建临时变量。</p>
<p><strong>右值引用：</strong> 相当于指针指向某个右值，右值没有地址意味着创建了临时变量来存储。类似于左值引用使用const，但是使用了const无法修改，这里可以修改。</p>
<p>为何会有左右值？引用实际上就是简化了指针，或者说内存标识符。为了精确控制内存生命周期，避免没必要的内存拷贝。</p>
<p>例如：在深拷贝时，直接将传入的右值内存拿过来，因为右值是临时创建的，不可能再用。可移动对象在<strong>需要拷贝且被拷贝者之后不再被需要</strong>的场景，可以使用 <code>std::move</code> 将左值转换成右值，提升性能。但如果像将右值转换成左值怎么办？<code>std::forward&lt;T&gt;(rlValue)</code>，会左转右或右转左。</p>
<h2 id="构造函数初始化列表">构造函数初始化列表</h2>
<p>在函数下面直接冒号对成员变量赋值。</p>
<p>为什么要使用这个？</p>
<ol>
<li>不是所有成员都可以通过形参赋值的，比如引用类型，const类型。</li>
<li>为了一些性能原因，对于类里面有声明类的话，编译器会先把里面声明的类构建一下，然后再进入构造函数类型，再调用赋值拷贝函数，然后再析构最初初始化的类。使用初始化列表后，就会在外面的类初始化的适合就直接把传入的参数给它了，就不会再初始化了。省去了3步：最初的构建函数，最初的构建好的类的析构函数，赋值拷贝函数。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClassB</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    MyClassB(){std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;constructorB called&#34;</span> <span style="color:#f92672">&lt;&lt;</span> cnt<span style="color:#f92672">++</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;}
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">~</span>MyClassB(){std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;destructorB called&#34;</span> <span style="color:#f92672">&lt;&lt;</span> cnt<span style="color:#f92672">++</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;}
</span></span><span style="display:flex;"><span>    MyClassB <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(MyClassB b)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;operator= called&#34;</span> <span style="color:#f92672">&lt;&lt;</span> cnt<span style="color:#f92672">++</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClassA</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    MyClassA(MyClassB b)
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//或初始化列表 :bina(b)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    {
</span></span><span style="display:flex;"><span>        bina<span style="color:#f92672">=</span>b;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;constructorA called&#34;</span> <span style="color:#f92672">&lt;&lt;</span> cnt<span style="color:#f92672">++</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">~</span>MyClassA(){std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;destructorA called&#34;</span> <span style="color:#f92672">&lt;&lt;</span> cnt<span style="color:#f92672">++</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;}
</span></span><span style="display:flex;"><span>    MyClassB bina;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    MyClassB b;
</span></span><span style="display:flex;"><span>    MyClassA a(b);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>初始化列表输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>constructorB called0 main.B构建
</span></span><span style="display:flex;"><span>constructorA called1 main.A构建
</span></span><span style="display:flex;"><span>destructorB called2  析构形参B
</span></span><span style="display:flex;"><span>destructorA called3  析构main.A 对应1
</span></span><span style="display:flex;"><span>destructorB called4  A.B 析构自己
</span></span><span style="display:flex;"><span>destructorB called5  析构main.B 对应0
</span></span></code></pre></div><p>=赋值输出：标有*的是多的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>constructorB called0 main.B构建
</span></span><span style="display:flex;"><span>* constructorB called1 A.B初始化构建
</span></span><span style="display:flex;"><span>* operator= called2    A.B赋值
</span></span><span style="display:flex;"><span>* destructorB called3  A.B初始化时的类析构 对应1
</span></span><span style="display:flex;"><span>constructorA called4 main.A构建
</span></span><span style="display:flex;"><span>destructorB called5  析构形参B
</span></span><span style="display:flex;"><span>destructorA called6  main.A析构 对应4
</span></span><span style="display:flex;"><span>destructorB called7  A.B析构
</span></span><span style="display:flex;"><span>destructorB called8  main.B析构 对应0
</span></span></code></pre></div><h2 id="重载">重载</h2>
<h3 id="函数重载与默认参数">函数重载与默认参数</h3>
<p>函数重载的函数签名要求：不同个数形参，形参类型不同，返回值不要求（因为在入口时需要知道使用哪个函数而不是结束时知道）。</p>
<p>注意：</p>
<ul>
<li>const和非const可以作为区分点</li>
<li>引用和非引用不可作为区分点</li>
</ul>
<h2 id="函数名称修饰">函数名称修饰</h2>
<p>函数的名字修饰（Decorated Name）就是编译器在编译期间创建的一个字符串，用来<strong>指明函数的定义或原型</strong>。</p>
<p>LINK程序或其他工具有时需要指定函数的名字修饰来定位函数的正确位置。 多数情况下程序员并不需要知道函数的名字修饰，LINK程序或其他工具会自动区分他们。</p>
<p>当然，在某些情况下需要指定函数的名字修饰，例如在C++程序中， 为了让LINK程序或其他工具能够匹配到正确的函数名字，就必须为<strong>重载函数和一些特殊的函数</strong>（如构造函数和析构函数）指定名字装饰。</p>
<p>另一种需要指定函数的名字修饰的情况是在<strong>汇编程序</strong>中调用C或C++的函数。如果函数名字，调用约定，返回值类型或函数参数有任何改变，原来的名字修饰就不再有效，必须指定新的名字修饰。C和C++程序的函数在内部使用不同的名字修饰方式，所以需要在C编译的库里额外声明<code>extern C</code>。</p>
<p><a href="https://www.cnblogs.com/eyeszjwang/articles/2303686.html">C++ 编译器的函数名修饰规则</a></p>
<h2 id="模板">模板</h2>
<p>有了重载为什么需要模板？仅仅参数类型不同的情况下，重载还需要一个一个写。而模板传入类型，直接就可以用一个函数补齐所有类型了，这个过程叫做具体化。而且任何类型都可以，哪怕未知的类型。模板不会减少执行代码量，他会生成不同的代码。</p>
<h3 id="模板函数">模板函数</h3>
<p>用法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span><span style="color:#75715e">//或template&lt;class T&gt;，二者完全相同
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> func(T arg){}
</span></span></code></pre></div><p>模板函数同样可以重载。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> func(T arg){}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//重新声明
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> func(T arg1, T arg2){}
</span></span></code></pre></div><h3 id="显式具体化">显式具体化</h3>
<p><strong>为什么需要显式具体化？</strong></p>
<p>模板可能对某些类型无法支持，需要手动新创建一个函数来处理。</p>
<p><strong>显式具体化和函数重载的区别？</strong></p>
<p>函数重载的匹配优先级大于显式具体化。</p>
<p>优先级：函数重载&gt;显式具体化&gt;模板函数。</p>
<p>用法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;&gt;</span> <span style="color:#66d9ef">void</span> func(<span style="color:#66d9ef">int</span> a){}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//或
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;&gt;</span> <span style="color:#66d9ef">void</span> func<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(<span style="color:#66d9ef">int</span> a){}
</span></span></code></pre></div><h3 id="显式实例化">显式实例化</h3>
<p><strong>实例化和具体化的区别？</strong></p>
<p>实例化从模板是真正生成代码了（在用时运作），具体化是确定模板函数的实现（还在声明那一层）。所以显式具体化在声明后必须<strong>给出实现</strong>，而实例化就是根据类型生成代码。</p>
<p>如果直接使用就是隐式实例化，但是可以自己手动实例化一个叫做显式实例化，不需要写实现！</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#66d9ef">void</span> func<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(<span style="color:#66d9ef">int</span> a);<span style="color:#75715e">//template后面没有&lt;&gt;
</span></span></span></code></pre></div><p><strong>为什么需要显式实例化</strong></p>
<p>避免隐式实例化时生成多份。</p>
<h3 id="重载解析">重载解析</h3>
<p>调用函数时，选择哪个函数？</p>
<p>执行顺序：</p>
<ol>
<li>函数名正确</li>
<li>参数数量正确</li>
<li>匹配函数参数类型
<ol>
<li>完全匹配，常规函数优于模板函数</li>
<li>类型提升转换</li>
<li>类型标准转换</li>
<li>类型自定义转换</li>
</ol>
</li>
</ol>
<h3 id="decltype-和-auto">decltype 和 auto</h3>
<p>二者都作为类型推断，都是C++11新增的<strong>关键字</strong>。<code>decltype</code>是为了解决模板里，不同类型运算后最终类型无法确定的问题。</p>
<p><strong>语法格式：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> varname <span style="color:#f92672">=</span> value;  <span style="color:#75715e">//auto的语法格式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">decltype</span>(exp) varname [<span style="color:#f92672">=</span> value];  <span style="color:#75715e">//decltype的语法格式
</span></span></span></code></pre></div><p><strong>主要区别：</strong></p>
<ul>
<li><code>auto</code>需要右边的值并且真的运行出来，而<code>decltype</code>只是根据表达式<code>exp</code>的类型做推断，不需要右边的<code>value</code>的任何东西，也不会运行<code>exp</code>。</li>
<li><code>decltype</code>可以保留exp的引用、const等信息。（识别引用需要额外加小括号<code>decltype((exp))</code>）</li>
</ul>
<p><strong>另外：</strong></p>
<p>在函数体内，<code>decltype</code>可以很好运转，但是返回时怎么办呢。返回值内的表达式<code>exp</code>是局部变量无法访问到。</p>
<p>于是有了后置返回类型（trailing return type）</p>
<p>模板函数可以这样写：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T1, <span style="color:#66d9ef">typename</span> T2<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> add(T1 t1, T2 t2) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">decltype</span>(t1 <span style="color:#f92672">+</span> t2)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> t1 <span style="color:#f92672">+</span> t2;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>普通函数也可以这样写</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> <span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">float</span> b) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">double</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> a <span style="color:#f92672">+</span> b;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="模板类">模板类</h3>
<p>大部分和模板函数一致，但是要注意模板类实例化时必须显式通过&lt;&gt;指定类型！不像模板函数可加可不加。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClass</span>{};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> my_func(T t);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//必须&lt;&gt;指明类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>MyClass<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> mc;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>my_func<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">//或者
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>my_func(<span style="color:#ae81ff">1</span>);
</span></span></code></pre></div><h3 id="模板参数">模板参数</h3>
<p><a href="https://en.cppreference.com/w/cpp/language/template_parameters">Template parameters and template arguments - cppreference.com</a></p>
<p>模板参数不只是类型。</p>
<table>
<thead>
<tr>
<th></th>
<th>有名字</th>
<th>无名字</th>
</tr>
</thead>
<tbody>
<tr>
<td>无默认值</td>
<td><code>template&lt;typename T&gt;</code></td>
<td><code>template&lt;typename&gt;</code></td>
</tr>
<tr>
<td>有默认值</td>
<td><code>template&lt;typename T = int&gt;</code></td>
<td><code>template&lt;typename = int&gt;</code></td>
</tr>
<tr>
<td>无默认值的可变数量</td>
<td><code>template&lt;typename... T&gt;</code></td>
<td><code>template&lt;typename...&gt;</code></td>
</tr>
</tbody>
</table>
<p>当一个参数没有名字的时候，多半是为了SFINAE。</p>
<h2 id="函数指针分析">函数指针分析</h2>
<p>如何声明一个函数指针？</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">//通用格式：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ReturnType (<span style="color:#f92672">*</span>NickName)(PramType1, PramType2);
</span></span><span style="display:flex;"><span><span style="color:#75715e">//实例
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>func)(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b);
</span></span><span style="display:flex;"><span><span style="color:#75715e">//或者迷惑人一下
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>f)();
</span></span></code></pre></div><p>如上，<code>NickName</code>是调用时使用的，很明显把<code>NickName</code>当作了一个地址。类似的还有<code>int *a;</code>，把<code>*a</code>当作<code>int</code>，那么<code>a</code>就是地址咯。</p>
<p>那么，嵌套一下？</p>
<p><strong>例子1</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>pf())())();
</span></span></code></pre></div><p>可以这样分析：</p>
<ol>
<li>
<p><code>pf()</code>是一个普普通通的函数声明（暂且忽略掉返回值），那么他返回的是剩下的一坨，姑且可以拆分成这样：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>T <span style="color:#a6e22e">pf</span>();
</span></span></code></pre></div></li>
<li>
<p>那么T是什么类型呢，可以看到除去<code>pf()</code>这4个字符后剩下的实际上是有<code>(*)()</code>这样的结构，这是函数指针。所以可以这样声明：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">int</span> (<span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>T)())();
</span></span></code></pre></div><p>此时可以看到T是一个函数指针！，所以最原始的pf函数返回了一个函数指针。</p>
</li>
<li>
<p>T是函数指针，那么*T就是函数咯，此时可以把<code>(*T)()</code>这几个字符拿掉（他们代表了执行<code>*T</code>这个函数），那么可以这样声明：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">int</span> (<span style="color:#f92672">*</span>T2)();
</span></span></code></pre></div><p>此刻就明白了。</p>
</li>
</ol>
<p>最终可以这样简化：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">int</span> (<span style="color:#f92672">*</span>T2)();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">T2</span> (<span style="color:#f92672">*</span>T)();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> T <span style="color:#a6e22e">pf</span>();
</span></span></code></pre></div><p>也可以使用后置类型简化：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> <span style="color:#a6e22e">pf</span>() <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">auto</span> (<span style="color:#f92672">*</span>)() <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>)();
</span></span><span style="display:flex;"><span><span style="color:#75715e">//进行一个实现
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span> <span style="color:#a6e22e">pf</span>() <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">auto</span> (<span style="color:#f92672">*</span>)() <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>)()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> []() <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>)()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> []() <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>例子2</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>fn())(<span style="color:#66d9ef">int</span>))())())();
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">int</span> (<span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>T)(<span style="color:#66d9ef">int</span>))())())();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">int</span> (<span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>T2)())())();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">int</span> (<span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>T3)())();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">int</span> (<span style="color:#f92672">*</span>T4)();
</span></span><span style="display:flex;"><span>T <span style="color:#a6e22e">fn</span>();
</span></span><span style="display:flex;"><span><span style="color:#75715e">//或者
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span> <span style="color:#a6e22e">fn</span>() <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">auto</span> (<span style="color:#f92672">*</span>)(<span style="color:#66d9ef">int</span>) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">auto</span> (<span style="color:#f92672">*</span>)() <span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">auto</span> (<span style="color:#f92672">*</span>)() <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>)();
</span></span></code></pre></div><h2 id="仿函数">仿函数</h2>
<p>一种避免使用函数指针的方式是使用仿函数。如下面传入了一个less函数来构建大顶堆。</p>
<p>仿函数实际上是重载了<code>operator()</code>。这样可以灵活的改变函数内部的参数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span> <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//仿函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">MyLess</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">operator</span>()(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> a, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> b) <span style="color:#66d9ef">const</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> a <span style="color:#f92672">&lt;</span> b;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> v {<span style="color:#ae81ff">8</span>,<span style="color:#ae81ff">9</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">7</span>,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">6</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">1</span>};
</span></span><span style="display:flex;"><span>    priority_queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>,MyLess<span style="color:#f92672">&gt;</span> pq(v.begin(), v.end());
</span></span><span style="display:flex;"><span>    pq.push(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>pq.empty()){
</span></span><span style="display:flex;"><span>        cout <span style="color:#f92672">&lt;&lt;</span> pq.top() <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>        pq.pop();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="存储持续性和链接性">存储持续性和链接性</h2>
<p>链接性决定了<strong>编译器在编译时到可不可以到其他文件里找</strong>，静态性决定<strong>当前作用域的变量是否共享内存区</strong>。可以看到全局变量和函数一旦加了static就不能在其他文件使用了哦。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>在当前文件定义声明格式</th>
<th>在其他文件中使用时的引用声明格式</th>
<th>链接性</th>
<th>静态性</th>
<th>作用域</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>全局</strong>变量</td>
<td>int a;</td>
<td>extern int a;</td>
<td>外部</td>
<td>是</td>
<td>全局</td>
</tr>
<tr>
<td><strong>全局</strong>变量</td>
<td>static int a;</td>
<td>不可使用</td>
<td>内部</td>
<td>是</td>
<td>当前文件</td>
</tr>
<tr>
<td>函数</td>
<td>void foo();</td>
<td>void foo();</td>
<td>外部</td>
<td>是</td>
<td>全局</td>
</tr>
<tr>
<td>函数</td>
<td>static void foo();</td>
<td>不可使用</td>
<td>内部</td>
<td>是</td>
<td>当前文件</td>
</tr>
<tr>
<td>局部变量</td>
<td>int a;</td>
<td>不可使用</td>
<td>无</td>
<td>否</td>
<td>当前代码块</td>
</tr>
<tr>
<td>局部变量</td>
<td>static int a;</td>
<td>不可使用</td>
<td>无</td>
<td>是</td>
<td>当前代码块</td>
</tr>
</tbody>
</table>
<p><strong>实例：</strong></p>
<p>test1.cpp</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> globalA <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> staticGlobalA <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Fn</span>() {}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span>  <span style="color:#a6e22e">StaticFn</span>() {}
</span></span></code></pre></div><p>test2.cpp</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">int</span> globalA;
</span></span><span style="display:flex;"><span><span style="color:#75715e">//extern int staticGlobalA;  can not use
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Fn</span>(); 
</span></span><span style="display:flex;"><span><span style="color:#75715e">//或 extern void Fn()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//extern void StaticFn();   can not use
</span></span></span></code></pre></div><p>以上都是不用命名空间时整的花活，在使用命名空间后，严格遵循“声明在header，定义在cpp”的规则，使用时引入命名空间就好了，相当于直接把整个东西都拿过来，不管是否是内部还是外部链接性，这时只有静态非静态之分。</p>
<h2 id="虚函数和纯虚函数">虚函数和纯虚函数</h2>
<ol>
<li>
<p>只要某类重写了父类的方法A（virtual），那么子类作为父类类型<strong>指针/引用</strong>传入时，调用方法A，就可以直接使用子类已经重写的方法，而不是父类的方法。若父类的方法不定义为virtual，则还是使用父类的方法。如果还是按照<strong>对象</strong>调用则virtual相当于没有，对象是谁就用谁的。</p>
<p>为什么只有指针才可以？使用对象调用方法属于静态联编，不会考虑对象实际是什么，只用到了对象的类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> foo() {
</span></span><span style="display:flex;"><span>        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Base::foo()&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Derived</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Base {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> foo() {
</span></span><span style="display:flex;"><span>        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Derived::foo()&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    Derived <span style="color:#f92672">*</span>d <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Derived();
</span></span><span style="display:flex;"><span>    d<span style="color:#f92672">-&gt;</span>foo();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">dynamic_cast</span><span style="color:#f92672">&lt;</span>Base <span style="color:#f92672">*&gt;</span>(d)<span style="color:#f92672">-&gt;</span>foo(); <span style="color:#75715e">//向上类型转换，没有丢失数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    Derived dd;
</span></span><span style="display:flex;"><span>    dd.foo();
</span></span><span style="display:flex;"><span>    Base bb <span style="color:#f92672">=</span> dd; <span style="color:#75715e">//进行了赋值拷贝，只将Derived里的Base部分传过来
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    bb.foo();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">Derived::foo()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">Derived::foo()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">Derived::foo()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">Base::foo()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span></code></pre></div><p>在Java里，一个类实现一个Interface，然后就可以作为Interface传入，就可以调用这个类自己实现的方法，C++这里实现机制完全和Java一致了，只不过C++没有interface关键字，强行用class去模拟interface。</p>
<p>在Go里，struct实现了interface后，就可以传入该struct，然后使用该struct实现的interface的方法。其实就是实现了真正意义上的“接口”。</p>
</li>
<li>
<p>override与final</p>
<p>要想明确子类实现的<strong>是</strong>父类的方法，加override关键字在子类实现方法签名里，避免写错。</p>
<p>要想确定子类实现的<strong>不是</strong>父类的方法，加final关键字在子类实现方法签名里，避免写错。</p>
<p>实现父类方法时，子类方法要满足：函数名、入参、返回值完全一致，但是当返回类的this指针时，返回值可以不一样。</p>
</li>
</ol>
<p>​	3.虚函数的实现原理</p>
<p>​		虚函数使用<strong>虚函数表</strong>实现，它是编译期的<strong>静态数组</strong>，类有一个隐藏成员指向它。每个类实现时，都会创建一个虚表，虚表记录了各个虚函数的入口地址，若自己的类有实现，就指向自己的函数，否则指向基类的虚函数。若派生类继续虚下去，则更新地址，不会记录路径上的虚函数。使用<strong>第一个</strong>虚函数就是使用数组的<strong>第一个</strong>元素。</p>
<ol start="4">
<li>纯虚函数和抽象类</li>
</ol>
<p>​		在虚函数后=0即为纯虚函数。含有纯虚函数的类成为抽象类，无法实现。子类继承抽象类时应当实现里面的纯虚方法。此处概念和Java的接口-抽象类几乎完全一致。</p>
<ol start="5">
<li>
<p>在继承中为什么一般<strong>虚析构函数</strong>，而不是<strong>虚构造函数</strong>？</p>
<p>从类的生命周期谈起，子类需要继承父类的相关数据，所以从父类开始构造，父类构造完子类构造，父类构造函数不能为虚函数，否则父类数据没有。而在析构时，因为是以父类指针调用的子类，从父类指针调用父类的析构方法，如果父类析构函数不设为虚的，那么子类的析构函数将无法调用，可能会引起<strong>内存泄漏</strong>。</p>
</li>
</ol>
<h2 id="存储区">存储区</h2>
<ul>
<li>
<p><strong>栈</strong>：存放函数的参数值，局部变量，函数执行结束时会被自动释放。栈内存分配运算内置于处理器的指令集中，效率高，但是容量有限。</p>
</li>
<li>
<p><strong>堆</strong>（动态内存分配）：通过new和malloc由低到高分配，由delete或free手动释放或者程序结束自动释放。动态内存的生存期人为决定，使用灵活。缺点是容易分配/释放不当容易造成内存泄漏，频繁分配/释放会产生大量内存碎片。 若程序员不释放，程序结束时可能由操作系统回收</p>
</li>
<li>
<p><strong>全局/静态存储区域</strong>：存全局变量，静态变量。程序编译时内存已分配好，并存在于程序整个运行期间，程序结束后由系统统一释放</p>
<p>全局变量和静态变量被分配到同一块内存中。
C 语言中，全局变量又分为初始化的和未初始化的。初始化的全局变量和静态变量在一块区域，未初始化的全局变量与静态变量在相邻的另一块区域。同时未被初始化的对象存储区可以通过 void* 来访问和操纵，程序结束后由系统自行释放。</p>
<p>在 C++ 里面没有区分，他们共同占用同一块内存区。</p>
</li>
<li>
<p><strong>常量区</strong>： 存放常量，程序结束时由系统释放，const + var_id 为右值。</p>
</li>
<li>
<p><strong>程序代码区</strong>： 存放函数体的二进制代码</p>
</li>
</ul>
<h2 id="成员函数const和mutable">成员函数const和mutable</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">C</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">change</span>() <span style="color:#66d9ef">const</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        a <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;<span style="color:#75715e">//错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        b <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;<span style="color:#75715e">//正确
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> a;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">mutable</span> <span style="color:#66d9ef">int</span> b;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>const放在成员函数后面可以让函数不改变类的变量，若又想改变，需要在成员变量前加mutable。</p>
<p>成员函数const保证不更改对象。const对象调用的方法只能是const方法，以此保证const。</p>
<p>当const和非const成员函数共存时，const对象只会调用const成员函数，非const只会调用非const成员函数。</p>
<h2 id="友元函数">友元函数</h2>
<p><strong>解决了什么问题？</strong></p>
<p>非类成员函数可以访问类私有变量</p>
<p>友元函数定义在类内，但不是类的成员函数。</p>
<p><strong>使用场景举例</strong></p>
<p>二元运算符重载，常规<code>C operator+(int a)</code>，使用时必须按照顺序<code>c + 1</code>或<code>c.operator+(1)</code>，而不能<code>1 + c</code>。</p>
<p>此时可以使用类外运算符重载，但是类外访问不到类内变量怎么办？使用友元函数就可以。</p>
<p>此外，像一元运算符<code>&lt;&lt;</code>，必须使用<code>&lt;&lt;</code></p>
<p><strong>遇到问题</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">C</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">+</span>(<span style="color:#66d9ef">int</span> a) <span style="color:#66d9ef">const</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> num <span style="color:#f92672">+</span> a;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> num;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    C c;
</span></span><span style="display:flex;"><span>    cout <span style="color:#f92672">&lt;&lt;</span> c <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;<span style="color:#75715e">//可以
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//cout &lt;&lt; 1 + c;//不可以
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p><strong>解决方案</strong> 友元函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">C</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">+</span>(<span style="color:#66d9ef">int</span> a) <span style="color:#66d9ef">const</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> num <span style="color:#f92672">+</span> a;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">friend</span> <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">+</span>(<span style="color:#66d9ef">int</span> a, C c);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> num;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">+</span>(<span style="color:#66d9ef">int</span> a, C c)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> a <span style="color:#f92672">+</span> c.num;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*更优雅的实现
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">int operator+(int a, C c)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">{
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    return c + a;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    C c;
</span></span><span style="display:flex;"><span>    cout <span style="color:#f92672">&lt;&lt;</span> c <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;<span style="color:#75715e">//可以
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> c;<span style="color:#75715e">//可以了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h2 id="多继承">多继承</h2>
<p>c++ 支持多继承，使用了一些操作让基类们不会冲突。</p>
<ol>
<li>
<p>基类函数/变量冲突？</p>
<p>使用类作用域解析<code>::</code></p>
</li>
<li>
<p>菱形继承创建多个类如何解决？</p>
<p>使用虚基类，可以保证只创建一个基类。否则以下将创建两个。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>{};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">virtual</span> A{};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">C</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">virtual</span> A{};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">D</span> <span style="color:#f92672">:</span> B, C {};
</span></span></code></pre></div></li>
<li>
<p>菱形继承，若D对B，C传不同数据，而BC用这些数据对A的初始化不同怎么办【自动传递信息】？</p>
<p>在虚基类的情况下，这样是不允许的，只能使用默认构造，或者直接在D中显式调用A构造函数。</p>
<p>而在普通基类的情况下，由于各自创建了一个基类，当然可以这样做，而在D中显式调用A构造函数是不可以的。</p>
</li>
</ol>
<h2 id="内存对齐">内存对齐</h2>
<p>首先找到<code>block = min(max(sizeof(member)), pack_pram)</code>，然后从头填充，每一次都分配block大小，下一个如果不能塞进上一个，则另起一个新的block，如果仍有结构体则拆开。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#pragma pack(8)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">A</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> a;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> b;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> c;
</span></span><span style="display:flex;"><span>};<span style="color:#75715e">//16
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">B</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> a;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> c;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> b;
</span></span><span style="display:flex;"><span>};<span style="color:#75715e">//24
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">C</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> a;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> b;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> c;
</span></span><span style="display:flex;"><span>};<span style="color:#75715e">//16
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">D</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> b;
</span></span><span style="display:flex;"><span>};<span style="color:#75715e">//1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">E</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> b;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> a;
</span></span><span style="display:flex;"><span>};<span style="color:#75715e">//4+4=8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma pack(1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">E2</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> b;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> c;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> a;
</span></span><span style="display:flex;"><span>};<span style="color:#75715e">//3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma pack(4)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">F</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> a;
</span></span><span style="display:flex;"><span>    E2 e;
</span></span><span style="display:flex;"><span>};<span style="color:#75715e">//4 //将E2拆开，重新计算pack
</span></span></span></code></pre></div><h2 id="类型转换">类型转换</h2>
<p><strong>C语言暴力版 (type) var 相当于staic_cast</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span> b <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span>)a;
</span></span></code></pre></div><h3 id="dynamic_cast">dynamic_cast</h3>
<p>用于不同层次类间的类型转化，带有安全检查，子类指针不能指向父类对象</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base</span>{};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Derived</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Base{};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    Derived d;
</span></span><span style="display:flex;"><span>    Base <span style="color:#f92672">*</span>b<span style="color:#f92672">=</span><span style="color:#66d9ef">dynamic_cast</span><span style="color:#f92672">&lt;</span>Base<span style="color:#f92672">*&gt;</span>(<span style="color:#f92672">&amp;</span>d);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//    Base bb;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//    Derived *dd=dynamic_cast&lt;Derived*&gt;(&amp;bb); //出错
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h3 id="static_cast">static_cast</h3>
<p>类型间转换，当然也可以用作dynamic_cast</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span> b <span style="color:#f92672">=</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>(a);
</span></span></code></pre></div><h3 id="reinterpret_cast">reinterpret_cast</h3>
<p>重新解释指针，指针间转换，可以用作dynamic_cast，参数必须是指针，否则出错。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> a;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span><span style="color:#f92672">*</span> b <span style="color:#f92672">=</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">*&gt;</span>(a);
</span></span></code></pre></div><h3 id="const_cast">const_cast</h3>
<p>如果不用const_cast，通过a改变b内存的值根本不可能。        ·</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> b<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>a <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>b;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> pb <span style="color:#f92672">=</span> <span style="color:#66d9ef">const_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">*&gt;</span>(a);
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>pb<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>     <span style="color:#75715e">//int *c = &amp;(*a);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//Cannot initialize a variable of type &#39;int *&#39; with an rvalue of type &#39;const int *&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>a <span style="color:#f92672">&lt;&lt;</span> endl; <span style="color:#75715e">// 2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h3 id="例子类之间的转换">例子：类之间的转换</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> PrintA(){}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> A{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> PrintB(){}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    A a, <span style="color:#f92672">*</span>pa;
</span></span><span style="display:flex;"><span>    B b,<span style="color:#f92672">*</span>pb;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//子类使用父类方法 天经地义
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//直接使用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    b.PrintA();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//dynamic cast
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">dynamic_cast</span><span style="color:#f92672">&lt;</span>A<span style="color:#f92672">*&gt;</span>(<span style="color:#f92672">&amp;</span>b)<span style="color:#f92672">-&gt;</span>PrintA();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//static cast
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>A<span style="color:#f92672">*&gt;</span>(<span style="color:#f92672">&amp;</span>b)<span style="color:#f92672">-&gt;</span>PrintA();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//父类使用子类方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//直接使用，当然不行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//a.PrintB();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//隐式类型转换 不可以
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//pa = &amp;b;pa-&gt;PrintB();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//dynamic_cast 不可以，只能子类转父类
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//dynamic_cast&lt;B*&gt;(&amp;a);pb-&gt;PrintB();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//强制类型转换 不可以
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//((A*)b)-&gt;PrintA();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//static_cast 可以，奇迹出现了，有风险：a中没有B的数据，若B的方法使用数据则UB
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>B<span style="color:#f92672">*&gt;</span>(<span style="color:#f92672">&amp;</span>a)<span style="color:#f92672">-&gt;</span>PrintB();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="黑科技">黑科技</h2>
<h3 id="模板里的typename">模板里的typename</h3>
<p>在模板函数里可以帮助编译器区分static成员和类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>Class MyClass
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">typename</span> T<span style="color:#f92672">::</span>SubType <span style="color:#f92672">*</span> ptr;
</span></span><span style="display:flex;"><span>  ...
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><a href="https://stackoverflow.com/questions/1600936/officially-what-is-typename-for">c++ - Officially, what is typename for? - Stack Overflow</a></p>
<h3 id="typeid-打印类型名称">typeid 打印类型名称</h3>
<p>需包含<!-- raw HTML omitted --></p>
<p>输入RTTI（run-time type information）的一部分。</p>
<h3 id="std算法库">std::算法库</h3>
<p>注意：如果算法仅仅是替代了for循环，那么std算法适用于序列化容器。容器自己有相应方法时不要使用std算法。</p>
<ul>
<li>for_each 对于容器内每一个元素进行操作</li>
<li>count_if 如果符合某条件则计数，返回计数</li>
<li>accumulate 累加（累计操作）</li>
<li>find_if 循序查找</li>
<li>binary_search 二分查找</li>
</ul>
<h3 id="sfinae">SFINAE</h3>
<p>Subsituation failure is not an error。实例化失败不是错误。</p>
<p>目的是模板实例化时，如果我们选择重载的话，会提供多个实例化选择。这时当编译器遇到第一个无法实例化的模板的时候继续<strong>查看其他模板能否匹配</strong>，而不是直接error结束编译。</p>
<p>相当于实现了<strong>模板实例化时的重载</strong>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;type_traits&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span>... Ts<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> void_t <span style="color:#f92672">=</span> <span style="color:#66d9ef">void</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//#1 否则就实例化这个
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//typename=void 就是一个开关，如果第二选项存在就不使用这个
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T, <span style="color:#66d9ef">typename</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">void</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">has_typedef_foobar</span> <span style="color:#f92672">:</span> std<span style="color:#f92672">::</span>false_type {};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//#2 T::foobar获取成功，那么自然就选择这个进行实例化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">has_typedef_foobar</span><span style="color:#f92672">&lt;</span>T, void_t<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">::</span>foobar<span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">:</span> std<span style="color:#f92672">::</span>true_type {};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">foo</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">using</span> foobar <span style="color:#f92672">=</span> <span style="color:#66d9ef">float</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>boolalpha;
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> has_typedef_foobar<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>value <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;<span style="color:#75715e">//int::foobar失败 进入#1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> has_typedef_foobar<span style="color:#f92672">&lt;</span>foo<span style="color:#f92672">&gt;::</span>value <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;<span style="color:#75715e">//foo::foobar成功 进入#2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h3 id="tuple">tuple</h3>
<p>元组，融合任意类型和任意个数个元素。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>tuple<span style="color:#f92672">&lt;</span>Ty1,Ty2<span style="color:#f92672">&gt;</span> t1(e1,e2);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> t2 <span style="color:#f92672">=</span> make_tuple(e1,e2);
</span></span><span style="display:flex;"><span>get<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0</span><span style="color:#f92672">&gt;</span>(t1);
</span></span><span style="display:flex;"><span>get<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0</span><span style="color:#f92672">&gt;</span>(t2) <span style="color:#f92672">=</span> get<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0</span><span style="color:#f92672">&gt;</span>(t1);
</span></span><span style="display:flex;"><span>tuple_size<span style="color:#f92672">&lt;</span>tuple<span style="color:#f92672">&lt;</span>Ty1,Ty2<span style="color:#f92672">&gt;&gt;::</span>value;
</span></span><span style="display:flex;"><span>tuple_element<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0</span>, tuple<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;&gt;::</span>type(<span style="color:#ae81ff">2.0</span>);<span style="color:#75715e">//类型强转
</span></span></span></code></pre></div><p>内部实现是利用模板可变参数递归解开的特点实例化一个继承类的链条。每个类仅有一个成员。</p>
<h3 id="bind">bind</h3>
<p>绑定参数到某个位置。见链接 实现stdbind</p>
<h3 id="type-traits">type traits</h3>
<p>类型萃取，在编译期就得到某个变量的属性：是否是const，是否是class，是否是function等等。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">M</span> {
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    is_floating_point<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>value;
</span></span><span style="display:flex;"><span>    has_virtual_destructor<span style="color:#f92672">&lt;</span>M<span style="color:#f92672">&gt;::</span>value;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>原理是<strong>静态多态加上typedef</strong> 或者是 编译器提供的<strong>内置的</strong>函数。</p>
<p><a href="https://gcc.gnu.org/onlinedocs/gcc/Type-Traits.html">GCC内置函数Type Traits (Using the GNU Compiler Collection (GCC))</a></p>
<h3 id="设置entry_point">设置entry_point</h3>
<p>C程序允许设定一个entry_point作为启动函数，而不是main。</p>
<p>linux + gcc 下的一个简单的C程序设置入口函数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">my_main</span>(){
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;my_main&#34;</span>);
</span></span><span style="display:flex;"><span>    exit(<span style="color:#ae81ff">0</span>);<span style="color:#75715e">//此处必须有此代码，否则会segment fault，因为之后要进行堆空间分配
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	printf(<span style="color:#e6db74">&#34;main&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>gcc -e my_main test.c
</span></span></code></pre></div><h3 id="embedded-pointer">embedded pointer</h3>
<p>嵌入式指针，指在构建链表的时候可以使用union，将数据和指针共用内存。节省了一个指针的空间。概念图如下。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>---------------------
</span></span><span style="display:flex;"><span>|next  | data       |
</span></span><span style="display:flex;"><span>---------------------
</span></span><span style="display:flex;"><span>---------------------
</span></span><span style="display:flex;"><span>|next  | data       |
</span></span><span style="display:flex;"><span>---------------------
</span></span><span style="display:flex;"><span>---------------------
</span></span><span style="display:flex;"><span>|      data         |
</span></span><span style="display:flex;"><span>---------------------
</span></span></code></pre></div>
  </div>

  <footer class="post-footer">
    

    

    
    
  </footer>
  
  <div class="comments">
  <div class="comments">



</div>
  </div>
</article>

  <div class="foot">
  
  &copy; 2019 - 2023 &#183;
  <a href="/"> YuYoung&#39;s Blog </a> &nbsp;&nbsp;
  <a href="#"><i class="fas fa-chevron-up"></i></a>
</div>
</body>
  <script src="/js/lazyload.min.js"></script>
<script>
  var lazyImage = new LazyLoad({container: document.getElementById('article')});
</script>



<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.slim.min.js" integrity="sha256-/SIrNqv8h6QGKDuNoLGA4iret+kyesCkHGzVUUV0shc=" crossorigin="anonymous"></script>
<script>
    (function() {
        var $toc = $('#TableOfContents');
        if ($toc.length > 0) {
            var $window = $(window);

            function onScroll(){
                var currentScroll = $window.scrollTop();
                var h = $('.post-text h1, .post-text h2, .post-text h3, .post-text h4, .post-text h5, .post-text h6');
                var id = "";
                h.each(function (i, e) {
                    e = $(e);
                    if (e.offset().top - 10 <= currentScroll) {
                        id = e.attr('id');
                    }
                });
                var active = $toc.find('a.active');
                if (active.length == 1 && active.eq(0).attr('href') == '#' + id) return true;

                active.each(function (i, e) {
                    $(e).removeClass('active').siblings('ul').hide();
                });
                $toc.find('a[href="#' + id + '"]').parentsUntil('#TableOfContents').each(function (i, e) {
                    $(e).children('a').addClass('active').siblings('ul').show();
                });
            }

            $window.on('scroll', onScroll);
            $(document).ready(function() {
                $toc.find('a').parent('li').find('ul').hide();
                onScroll();
                document.getElementsByClassName('post-toc')[0].style.display = '';
            });
        }
    })();
</script>


</html>
