<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
    <script type="application/ld+json">

{  
  "@context":"http://schema.org",
  "@type":"Website",
  "@id":"https:\/\/yuyoung32.github.io",
  "author": {
    "@type": "Person",
    "name": "YuYoung",
    
    "image": "https://s1.ax1x.com/2022/04/09/LPwdFs.jpg"
    
  },
  "name":"YuYoung的博客",
  "description":"",
  "url":"https:\/\/yuyoung32.github.io\/post\/c\u002b\u002b%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E4%B8%8Eallocator\/",
  "keywords":"[]"
}

</script>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="generator" content="Hugo 0.96.0 with theme Tranquilpeak 0.5.3-BETA">
<meta name="author" content="YuYoung">
<meta name="keywords" content="">
<meta name="description" content="">


<meta property="og:description" content="">
<meta property="og:type" content="article">
<meta property="og:title" content="C&#43;&#43;动态内存分配与allocator">
<meta name="twitter:title" content="C&#43;&#43;动态内存分配与allocator">
<meta property="og:url" content="https://yuyoung32.github.io/post/c&#43;&#43;%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E4%B8%8Eallocator/">
<meta property="twitter:url" content="https://yuyoung32.github.io/post/c&#43;&#43;%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E4%B8%8Eallocator/">
<meta property="og:site_name" content="YuYoung的博客">
<meta property="og:description" content="">
<meta name="twitter:description" content="">
<meta property="og:locale" content="zh-cn">

  
    <meta property="article:published_time" content="2022-11-24T16:52:52">
  
  
    <meta property="article:modified_time" content="2022-11-24T16:52:52">
  
  
  
    
      <meta property="article:section" content="c&#43;&#43;">
    
      <meta property="article:section" content="语言律师">
    
  
  
    
      <meta property="article:tag" content="c&#43;&#43;">
    
  


<meta name="twitter:card" content="summary">







  <meta property="og:image" content="https://s1.ax1x.com/2022/04/09/LPwdFs.jpg">
  <meta property="twitter:image" content="https://s1.ax1x.com/2022/04/09/LPwdFs.jpg">





  <meta property="og:image" content="https://s1.ax1x.com/2022/11/24/zGzGp6.png">
  <meta property="twitter:image" content="https://s1.ax1x.com/2022/11/24/zGzGp6.png">


    <title>C&#43;&#43;动态内存分配与allocator</title>

    <link rel="icon" href="https://s1.ax1x.com/2022/04/09/LPwdFs.jpg">
    

    

    <link rel="canonical" href="https://yuyoung32.github.io/post/c&#43;&#43;%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E4%B8%8Eallocator/">

    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" integrity="sha512-iBBXm8fW90+nuLcSKlbmrPcLa0OT92xO1BIsZ+ywDWZCvqsWgccV3gFoRBv0z+8dLJgyAHIhR35VZc2oM/gI1w==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha512-H9jrZiiopUdsLpg94A333EfumgUBpO9MdbxStdeITo+KEIMaNfHNvwyjjDJb+ERPaRS6DpyRlKbvPUasNItRyw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    
    
    
    <link rel="stylesheet" href="https://yuyoung32.github.io/css/style-h6ccsoet3mzkbb0wngshlfbaweimexgqcxj0h5hu4h82olsdzz6wmqdkajm.min.css" />
    
    

    
      
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6QCN1ZG6DB"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-6QCN1ZG6DB', { 'anonymize_ip': false });
}
</script>

    
    
  </head>

  <body>
    <div id="blog">
      <header id="header" data-behavior="5">
  <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
  <div class="header-title">
    <a class="header-title-link" href="https://yuyoung32.github.io/" aria-label="去首页">YuYoung的博客</a>
  </div>
  
    
      <a class="header-right-picture "
         href="https://yuyoung32.github.io/#about" aria-label="打开链接: /#about">
    
    
    
      
        <img class="header-picture" src="https://s1.ax1x.com/2022/04/09/LPwdFs.jpg" alt="作者的图片" />
      
    
    </a>
  
</header>

      <nav id="sidebar" data-behavior="5">
  <div class="sidebar-container">
    
      <div class="sidebar-profile">
        <a href="https://yuyoung32.github.io/#about" aria-label="阅读有关作者的更多信息">
          <img class="sidebar-profile-picture" src="https://s1.ax1x.com/2022/04/09/LPwdFs.jpg" alt="作者的图片" />
        </a>
        <h4 class="sidebar-profile-name">YuYoung</h4>
        
          <h5 class="sidebar-profile-bio">每天多进步一点</h5>
        
      </div>
    
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://yuyoung32.github.io/" title="Home">
    
      <i class="sidebar-button-icon fas fa-lg fa-home" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">首页</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://yuyoung32.github.io/tags" title="Tags">
    
      <i class="sidebar-button-icon fas fa-lg fa-tags" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">标签</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://yuyoung32.github.io/archives" title="Archives">
    
      <i class="sidebar-button-icon fas fa-lg fa-archive" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">归档</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://yuyoung32.github.io/#about" title="About">
    
      <i class="sidebar-button-icon fas fa-lg fa-question" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">关于</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://github.com/yuyoung32" target="_blank" rel="noopener" title="GitHub">
    
      <i class="sidebar-button-icon fab fa-lg fa-github" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">GitHub</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://yuyoung32.github.io/index.xml" title="RSS">
    
      <i class="sidebar-button-icon fas fa-lg fa-rss" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">RSS</span>
    </a>
  </li>


    </ul>
  </div>
</nav>

      

      <div id="main" data-behavior="5"
        class="
               hasCoverMetaIn
               ">
        <article class="post" id="top">
          
          
            <div class="post-header main-content-wrap text-left">
  
    <h1 class="post-title">
      C&#43;&#43;动态内存分配与allocator
    </h1>
  
  
  <div class="postShorten-meta post-meta">
    
      <time datetime="2022-11-24T16:52:52&#43;08:00">
        
  
  
  
  
    2022年11月24日
  

      </time>
    
    
  
  
    <span>发布在</span>
    
      <a class="category-link" href="https://yuyoung32.github.io/categories/c&#43;&#43;">c&#43;&#43;</a>, 
    
      <a class="category-link" href="https://yuyoung32.github.io/categories/%e8%af%ad%e8%a8%80%e5%be%8b%e5%b8%88">语言律师</a>
    
  

  </div>

</div>
          
          <div class="post-content markdown">
            <div class="main-content-wrap">
              <h1 id="table-of-contents">目录</h1>
<nav id="TableOfContents">
  <ul>
    <li><a href="#内存分配call-stack">内存分配call stack</a>
      <ul>
        <li><a href="#重载operator-new">重载operator new</a></li>
      </ul>
    </li>
    <li><a href="#内存池构建思路">内存池构建思路</a>
      <ul>
        <li><a href="#gnu-c-pool_allocator-内存分配器">GNU C++ pool_allocator 内存分配器</a></li>
        <li><a href="#vc-crt-malloc实现sbh">VC++ CRT malloc实现：SBH</a></li>
      </ul>
    </li>
    <li><a href="#gnu内存分配器类别原理和选用">GNU内存分配器类别、原理和选用</a>
      <ul>
        <li><a href="#每次分配">每次分配</a></li>
        <li><a href="#内存池">内存池</a></li>
        <li><a href="#其他">其他</a></li>
      </ul>
    </li>
  </ul>
</nav>

<h2 id="内存分配call-stack">内存分配call stack</h2>
<p>分配内存</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>Foo<span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Foo(x);
</span></span><span style="display:flex;"><span><span style="color:#75715e">//等同于
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Foo<span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> (Foo<span style="color:#f92672">*</span>)<span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">new</span>(<span style="color:#66d9ef">sizeof</span>(Foo)); <span style="color:#75715e">//分配空间 此处可重载,使之不调用全局的::operator new
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">new</span>(p) Foo(x); <span style="color:#75715e">//placement new 创建对象(初始化内存)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//等同于
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">new</span>(size_t);
</span></span><span style="display:flex;"><span><span style="color:#75715e">//等同于
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>malloc(size_t);
</span></span></code></pre></div><p>释放内存</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">delete</span> p;
</span></span><span style="display:flex;"><span><span style="color:#75715e">//等同于
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>p<span style="color:#f92672">-&gt;~</span>Foo();<span style="color:#75715e">//析构函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">delete</span>(p); <span style="color:#75715e">//此处可重载,使之不调用全局的::operator delete 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//等同于
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">delete</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">//等同于
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>free(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>);
</span></span></code></pre></div><h3 id="重载operator-new">重载operator new</h3>
<p>注意：</p>
<p>在重载operator new，第一个参数必须是size_t形式</p>
<p>在重载operator delete时，第一个参数必须是void*形式</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClass</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//operator new(int a)//出错，第一个参数必须是size_t
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">new</span>(size_t size) {
</span></span><span style="display:flex;"><span>        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;MyClass new&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">malloc</span>(size);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">new</span>(size_t size, <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> ptr) {
</span></span><span style="display:flex;"><span>        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;MyClass new&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> malloc(size);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">delete</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> p) {
</span></span><span style="display:flex;"><span>        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;MyClass delete&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>        free(p);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h2 id="内存池构建思路">内存池构建思路</h2>
<h3 id="gnu-c-pool_allocator-内存分配器">GNU C++ pool_allocator 内存分配器</h3>
<p><strong>编译器在最终使用malloc时，分配的内存会在最终需求的上下有多余块</strong>，一方面是为了内存对齐，另一方面是为了调试时追踪。如下图，只有<code>user use</code>才是用户申请的空间。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>----------
</span></span><span style="display:flex;"><span>| cookie |
</span></span><span style="display:flex;"><span>----------
</span></span><span style="display:flex;"><span>| debug  |
</span></span><span style="display:flex;"><span>| header |
</span></span><span style="display:flex;"><span>----------
</span></span><span style="display:flex;"><span>| user   |
</span></span><span style="display:flex;"><span>| use    |
</span></span><span style="display:flex;"><span>----------
</span></span><span style="display:flex;"><span>| debug  |
</span></span><span style="display:flex;"><span>| tail   |
</span></span><span style="display:flex;"><span>----------
</span></span><span style="display:flex;"><span>| padding|
</span></span><span style="display:flex;"><span>----------
</span></span><span style="display:flex;"><span>| cookie |
</span></span><span style="display:flex;"><span>----------
</span></span></code></pre></div><p>内存分配器就要做到尽量减少多余空间的占用（减少cookie），<strong>减少调用malloc的次数</strong>。</p>
<p>思想就是<strong>内存池</strong>，实现就是预先分配大空间，大空间分成多个对象，对象间用链表相连（为了模拟离散空间）。此外，把每个池子面向的大小固定下来，比如8 16 24 32 40这样固定的值，超过最大固定值后交给malloc直接分配带cookie的块。概念图如下。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>    8     ----    16     ----    24    ----    32    ----    MAX
</span></span><span style="display:flex;"><span>    |
</span></span><span style="display:flex;"><span>----------    ----------
</span></span><span style="display:flex;"><span>| cookie |    | cookie |    
</span></span><span style="display:flex;"><span>----------    ----------
</span></span><span style="display:flex;"><span>| debug  |    | debug  |
</span></span><span style="display:flex;"><span>| header |    | header |
</span></span><span style="display:flex;"><span>----------    ----------
</span></span><span style="display:flex;"><span>| user   |    | user   |
</span></span><span style="display:flex;"><span>| use    |    | use    |    
</span></span><span style="display:flex;"><span>----------    ----------    
</span></span><span style="display:flex;"><span>| debug  |    | debug  |    
</span></span><span style="display:flex;"><span>| tail   |    | tail   |    
</span></span><span style="display:flex;"><span>----------    ----------    
</span></span><span style="display:flex;"><span>| padding|    | padding|    
</span></span><span style="display:flex;"><span>----------    ----------    
</span></span><span style="display:flex;"><span>| cookie |    | cookie |    
</span></span><span style="display:flex;"><span>----------    ----------    
</span></span><span style="display:flex;"><span>    |        
</span></span><span style="display:flex;"><span>----------
</span></span><span style="display:flex;"><span>| cookie |
</span></span><span style="display:flex;"><span>----------
</span></span><span style="display:flex;"><span>| debug  |
</span></span><span style="display:flex;"><span>| header |
</span></span><span style="display:flex;"><span>----------
</span></span><span style="display:flex;"><span>| user   |
</span></span><span style="display:flex;"><span>| use    |
</span></span><span style="display:flex;"><span>----------
</span></span><span style="display:flex;"><span>| debug  |
</span></span><span style="display:flex;"><span>| tail   |
</span></span><span style="display:flex;"><span>----------
</span></span><span style="display:flex;"><span>| padding|
</span></span><span style="display:flex;"><span>----------
</span></span><span style="display:flex;"><span>| cookie |
</span></span><span style="display:flex;"><span>----------
</span></span></code></pre></div><p>此外，因为是使用连续空间切割，然后模拟链表之间可以使用embedded pointer节省一个指针，概念图如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>---------------------
</span></span><span style="display:flex;"><span>|next  | data       |
</span></span><span style="display:flex;"><span>---------------------
</span></span><span style="display:flex;"><span>---------------------
</span></span><span style="display:flex;"><span>|next  | data       |
</span></span><span style="display:flex;"><span>---------------------
</span></span><span style="display:flex;"><span>---------------------
</span></span><span style="display:flex;"><span>|      data         |
</span></span><span style="display:flex;"><span>---------------------
</span></span></code></pre></div><p>这样每次分配出去后，当前指针指向下一个可用的块。回收时，直接将回收块的embedded pointer指向当前的，然后当前指针指向回收的就好了。不必专门清除。</p>
<p>在分配时，会根据需求大小查找free_list试图找到空闲的，若那个大小的没有空闲的块了，就会从池子里申请。若池子不够大，则申请一个较大的数值（round_up函数）作为池子，一部分用于当前空闲块的建立，一部分用于池子。</p>
<p>在回收时，pool_alloctor并不会真的还给系统，只是会返还给池子，只要程序在运行，这个池子就只会增加。</p>
<h3 id="vc-crt-malloc实现sbh">VC++ CRT malloc实现：SBH</h3>
<p>malloc和std::alloctor的调用层次。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>C++ Application
</span></span><span style="display:flex;"><span>|  |     |    |
</span></span><span style="display:flex;"><span>|  |     |  C++ Library(std::alloctor)
</span></span><span style="display:flex;"><span>|  |     |    |
</span></span><span style="display:flex;"><span>|  |   C++ primitives(new delete)
</span></span><span style="display:flex;"><span>|  |          |
</span></span><span style="display:flex;"><span>|  C Runtime CRT(malloc/free)
</span></span><span style="display:flex;"><span>|             |    
</span></span><span style="display:flex;"><span>OS API(VirtualAlloc)
</span></span></code></pre></div><p>VC++的malloc使用栈上小区块（Small Block Heap）内存分配器。思路类似于GNU C++的 pool_alloctor但细节处不同。</p>
<p>分为管理的部分和实际内存部分。</p>
<ul>
<li>管理部分使用一个有32个元素的数组，称为32个group。每个group是一个有64个双向链表节点的链表，用来管理不同大小的区块。此处使用VirtualAddress分配1MB地址空间。</li>
<li>实际内存部分有1MB，分为32个段，每个段就是32KB。每个段分为8个页，每页就是32/8=4KB，一个段内的页之间构成双向链表。此处使用VirtualMemory分配实际32KB内存（只有在使用时才会实际分配内存）。</li>
</ul>
<p>每个group管理一个段（32KB），32个group恰好管理32个内存段。也就是说每个group管理8个页。一个group是有64个链表的，第0个管理16B的，下一个管理32B，直到倒数第二个管理到1024B，而倒数第一个管理1024B以上的。因此，最初分配的8个页全部挂到最后一个链表上。</p>
<p>在分配时，和pool_alloctor相同的分大小管理造就了类似的分配回收逻辑。每次看看需求大小对应的链表中是否有空闲块，否则就去上一级要，然后还回去的时候并不还给上级，而是自己留着。就这样，最后一个链表上面挂着的大区块被下面小区块瓜分干净。</p>
<p>在回收时， 小区块会合并成大区块并挂到更高的链表上。最后，如果全部回收了就回到了一开始的一段8页全部挂到最后一个链表上的状态。</p>
<ul>
<li>
<p>如何判断全部回收的状态，或者说如何判断全部合并了呢？</p>
<p>group管理结构里面有一个字段用于计数分配次数，每分配一次+1，释放一次-1，当为0时意味着可以归还操作系统。</p>
</li>
<li>
<p>那么何时归还给操作系统呢？</p>
<p>当有两个全回收的group时，就把前一个group对应的内存归还系统。这叫做“defer”策略，避免频繁申请与归还。</p>
</li>
</ul>
<h2 id="gnu内存分配器类别原理和选用">GNU内存分配器类别、原理和选用</h2>
<h3 id="每次分配">每次分配</h3>
<p>直接分配具体大小。会因为malloc cookie问题额外占用空间。</p>
<h4 id="__gnu_cxxnew_alloctor"><code>__gnu_cxx::new_alloctor</code></h4>
<p>直接调用<code>operator new</code> 没有任何优化。<strong>这是所有容器默认的内存分配器。</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>pointer <span style="color:#a6e22e">allocate</span>(size_type __n, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (__n <span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>max_size())
</span></span><span style="display:flex;"><span>  		std<span style="color:#f92672">::</span>__throw_bad_alloc();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>_Tp<span style="color:#f92672">*&gt;</span>(<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">new</span>(__n <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(_Tp)));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">deallocate</span>(pointer __p, size_type)
</span></span><span style="display:flex;"><span>{ <span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">delete</span>(__p); }
</span></span></code></pre></div><h4 id="__gnu_cxxmalloc_alloctor"><code>__gnu_cxx::malloc_alloctor</code></h4>
<p>直接调用<code>malloc</code> 没有任何优化。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>pointer <span style="color:#a6e22e">allocate</span>(size_type __n, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (__n <span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>max_size())
</span></span><span style="display:flex;"><span>  		std<span style="color:#f92672">::</span>__throw_bad_alloc();
</span></span><span style="display:flex;"><span>	pointer __ret <span style="color:#f92672">=</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>_Tp<span style="color:#f92672">*&gt;</span>(std<span style="color:#f92672">::</span>malloc(__n <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(_Tp)));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>__ret)
</span></span><span style="display:flex;"><span>      std<span style="color:#f92672">::</span>__throw_bad_alloc();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> __ret;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">deallocate</span>(pointer __p, size_type)
</span></span><span style="display:flex;"><span>{ std<span style="color:#f92672">::</span>free(<span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span><span style="color:#f92672">*&gt;</span>(__p)); }
</span></span></code></pre></div><h3 id="内存池">内存池</h3>
<p>通过预先安排大空间，减少cookie占用。</p>
<h4 id="__gnu_cxx__pool_alloc"><code>__gnu_cxx::__pool_alloc</code></h4>
<p>分级池子，同上节[内存分配器思路](#GNU C++ pool_allocator 内存分配器)。使用场景：小区块频繁分配。特点：内存不会还给系统，维持在峰值空间。</p>
<h4 id="__gnu_cxxbitmap_allocator"><code>__gnu_cxx::bitmap_allocator</code></h4>
<p>使用bitmap直接管理每块内存，一块内存的大小和数据对象的大小相同。</p>
<p>一个单元内由4部分组成，64个块和64个bit用于表示状态，还有已使用的块的大小（unsigned int）和整个单元的大小。每个块的大小是固定的（是一个数据对象的大小如int），每个块被映射到一个bit上。</p>
<p>一个单元的分布如下图</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>------------------------------------------------------------------------------
</span></span><span style="display:flex;"><span>|整个单元的大小|已使用的block数|bit map(64bit)|block1|block2|block3|...|block64|
</span></span><span style="display:flex;"><span>------------------------------------------------------------------------------
</span></span></code></pre></div><p>一个单元二进制如下所示。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>     524=4B+2*4B+64*obj_size(assume 8) |             used blocks 0             |    bit map 2*32bit
</span></span><span style="display:flex;"><span>|00000000 00000000 00000010 00001100|00000000 00000000 00000000 00000000|00000000 00000000 00000000 00000000  00000000 00000000 00000000 00000000|data block1|data block2|...|data block64|
</span></span></code></pre></div><p>上述图示是第一个单元的大小，第一个单元用完后，后面会成倍增加，第二个单元是128个，第三个是256&hellip;。对应的bitmap和总大小都会变。此外，不同于pool_allocator，不同obj_type不会使用同一个bitmap_allocator。每次请求新的类型会创建新的bitmap_allocator实例。</p>
<p>在释放时，是以一整个单元为单位的。在整个单元释放后（使用的区块数为0），整个单元的存入一个数组，作为一个entry。最多存64个entry，这个数组根据block数从小到大维护大小，超过64个后会把最大的还给系统。在下次需要内存时优先从这个数组中找。</p>
<p>这种释放思路不像pool_alloc那样始终不还，也不像new_alloc那样直接归还，做了一个defer的处理。</p>
<h4 id="__gnu_cxx__mt_alloc"><code>__gnu_cxx::__mt_alloc</code></h4>
<p>多线程分配器，原理上是对pool_alloc的封装。多线程使用全局内存池，然后各个线程拥有自己的分级pool，各线程到自己的pool里拿内存。当各线程的pool需要内存时需要到全局内存池拿内存，此时原子操作从全局内存池拿内存。当全局内存池不够后，线程将直接从系统中拿内存，而不是请求扩容。</p>
<h3 id="其他">其他</h3>
<p><code>__gnu_cxx::array_allocator</code> 使用数组，而无需运行时使用动态内存。亦或者使用其他已经分配好的内存进行再分配。不会回收已经使用的内存。使用场景：一次性分配。已知需要多少空间，避免扩容。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>pointer <span style="color:#a6e22e">allocate</span>(size_type __n, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (_M_array <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> _M_used <span style="color:#f92672">+</span> __n <span style="color:#f92672">&gt;</span> _M_array<span style="color:#f92672">-&gt;</span>size())
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>__throw_bad_alloc();
</span></span><span style="display:flex;"><span>    pointer __ret <span style="color:#f92672">=</span> _M_array<span style="color:#f92672">-&gt;</span>begin() <span style="color:#f92672">+</span> _M_used;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//使用量_M_used恒加，使用过的内存不会再次使用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    _M_used <span style="color:#f92672">+=</span> __n;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> __ret;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">deallocate</span>(pointer, size_type)
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Does nothing.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div>
              


            </div>
          </div>
          <div id="post-footer" class="post-footer main-content-wrap">
            
            
<div class="post-actions-wrap">
  <nav >
    <ul class="post-actions post-action-nav">
      
        <li class="post-action">
          
            <a class="post-action-btn btn btn--disabled">
          
              <i class="fa fa-angle-left"></i>
              <span class="hide-xs hide-sm text-small icon-ml">下一篇</span>
            </a>
        </li>
        <li class="post-action">
          
            <a class="post-action-btn btn btn--default tooltip--top" href="https://yuyoung32.github.io/post/%E5%AE%9E%E7%8E%B0stdbind/" data-tooltip="实现std::bind" aria-label="上一篇: 实现std::bind">
          
              <span class="hide-xs hide-sm text-small icon-mr">上一篇</span>
              <i class="fa fa-angle-right"></i>
            </a>
        </li>
      
    </ul>
  </nav>
<ul class="post-actions post-action-share" >
  
    <li class="post-action hide-lg hide-md hide-sm">
      <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="分享这个帖子">
        <i class="fa fa-share-alt" aria-hidden="true"></i>
      </a>
    </li>
    
  
  
  <li class="post-action">
    
      <a class="post-action-btn btn btn--default" href="#top" aria-label="回到顶部">
      <i class="fa fa-arrow-up" aria-hidden="true"></i>
    
    </a>
  </li>
</ul>
</div>


            
  


          </div>
        </article>
        <footer id="footer" class="main-content-wrap">
  <span class="copyrights">
    &copy; 2022 YuYoung. All Rights Reserved
  </span>
</footer>

      </div>
      <div id="bottom-bar" class="post-bottom-bar" data-behavior="5">
        
<div class="post-actions-wrap">
  <nav >
    <ul class="post-actions post-action-nav">
      
        <li class="post-action">
          
            <a class="post-action-btn btn btn--disabled">
          
              <i class="fa fa-angle-left"></i>
              <span class="hide-xs hide-sm text-small icon-ml">下一篇</span>
            </a>
        </li>
        <li class="post-action">
          
            <a class="post-action-btn btn btn--default tooltip--top" href="https://yuyoung32.github.io/post/%E5%AE%9E%E7%8E%B0stdbind/" data-tooltip="实现std::bind" aria-label="上一篇: 实现std::bind">
          
              <span class="hide-xs hide-sm text-small icon-mr">上一篇</span>
              <i class="fa fa-angle-right"></i>
            </a>
        </li>
      
    </ul>
  </nav>
<ul class="post-actions post-action-share" >
  
    <li class="post-action hide-lg hide-md hide-sm">
      <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="分享这个帖子">
        <i class="fa fa-share-alt" aria-hidden="true"></i>
      </a>
    </li>
    
  
  
  <li class="post-action">
    
      <a class="post-action-btn btn btn--default" href="#top" aria-label="回到顶部">
      <i class="fa fa-arrow-up" aria-hidden="true"></i>
    
    </a>
  </li>
</ul>
</div>


      </div>
      

    </div>
    
    <div id="about">
  <div id="about-card">
    <div id="about-btn-close">
      <i class="fa fa-times"></i>
    </div>
    
      <img id="about-card-picture" src="https://s1.ax1x.com/2022/04/09/LPwdFs.jpg" alt="作者的图片" />
    
    <h4 id="about-card-name">YuYoung</h4>
    
      <div id="about-card-bio">每天多进步一点</div>
    
    
      <div id="about-card-job">
        <i class="fa fa-briefcase"></i>
        <br/>
        学生
      </div>
    
    
      <div id="about-card-location">
        <i class="fa fa-map-marker-alt"></i>
        <br/>
        杭州
      </div>
    
  </div>
</div>

    

    
  
    <div id="cover" style="background-image:url('https://s1.ax1x.com/2022/04/09/LPwmee.jpg');"></div>
  


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" integrity="sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcOP+u1T9qYdvdihz0PPSiiqn/+/3e7Jo4EaG7TubfWGUrMQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/highlight.min.js" integrity="sha512-z+/WWfyD5tccCukM4VvONpEtLmbAm5LDu7eKiyMQJ9m7OfPEDL7gENyDRL3Yfe8XAuGsS2fS4xSMnl6d30kqGQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha512-uURl+ZXMBrF4AwGaWmEetzrd+J5/8NRkWAvJx5sbPSSuOb0bZLqf+tOzniObO00BjHa/dD7gub9oCGMLPQHtQA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>


<script src="https://yuyoung32.github.io/js/script-yqzy9wdlzix4lbbwdnzvwx3egsne77earqmn73v9uno8aupuph8wfguccut.min.js"></script>


  
    <script async crossorigin="anonymous" defer integrity="sha512-gE8KAQyFIzV1C9+GZ8TKJHZS2s+n7EjNtC+IMRn1l5+WYJTHOODUM6JSjZhFhqXmc7bG8Av6XXpckA4tYhflnw==" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/apache.min.js"></script>
  

  
    <script async crossorigin="anonymous" defer integrity="sha512-EWROca+bote+7Oaaar1F6y74iZj1r1F9rm/ly7o+/FwJopbBaWtsFDmaKoZDd3QiGU2pGacBirHJNivmGLYrow==" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/go.min.js"></script>
  

  
    <script async crossorigin="anonymous" defer integrity="sha512-GDVzAn0wpx1yVtQsRWmFc6PhJiLBPdUic+h4GWgljBh904O3JU10fk9EKNpVyIoPqkFn54rgL2QBG4BmUTMpiQ==" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/http.min.js"></script>
  

  
    <script async crossorigin="anonymous" defer integrity="sha512-UgZlma8NzkrDb/NWgmLIcTrH7i/CSnLLDRFqCSNF5NGPpjKmzyM25qcoXGOup8+cDakKyaiTDd7N4dyH4YT+IA==" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/less.min.js"></script>
  

  
    <script async crossorigin="anonymous" defer integrity="sha512-lot9koe73sfXIrUvIPM/UEhuMciN56RPyBdOyZgfO53P2lkWyyXN7J+njcxIIBRV+nVDQeiWtiXg+bLAJZDTfg==" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/nginx.min.js"></script>
  

  
    <script async crossorigin="anonymous" defer integrity="sha512-Zd3e7XxHP00TD0Imr0PIfeM0fl0v95kMWuhyAS3Wn1UTSXTkz0OhtRgBAr4JlmADRgiXr4x7lpeUdqaGN8xIog==" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/puppet.min.js"></script>
  

  
    <script async crossorigin="anonymous" defer integrity="sha512-qtqDO052iXMSP+5d/aE/jMtL9vIIGvONgTJziC2K/ZIB1yEGa55WVxGE9/08rSQ62EoDifS9SWVGZ7ihSLhzMA==" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/scss.min.js"></script>
  

  
    <script async crossorigin="anonymous" defer integrity="sha512-1NmkjnEDnwwwcu28KoQF8vs3oaPFokQHbmbtwGhFfeDsQZtVFI8zW2aE9O8yMYdpdyKV/5blE4pSWw4Z/Sv97w==" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/stylus.min.js"></script>
  

  
    <script async crossorigin="anonymous" defer integrity="sha512-B2wSfruPjr8EJL6IIzQr1eAuDwrsfIfccNf/LCEdxELCgC/S/ZMt/Uvk80aD79m7IqOqW+Sw8nbkvha20yZpzg==" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/swift.min.js"></script>
  

  
    <script async crossorigin="anonymous" defer integrity="sha512-28oDiQZGKUVN6wQ7PSLPNipOcmkCALXKwOi7bnkyFf8QiMZQxG9EQoy/iiNx6Zxj2cG2SbVa4dXKigQhu7GiFw==" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/yaml.min.js"></script>
  


<script>
$(document).ready(function() {
  hljs.configure({ classPrefix: '', useBR: false });
  $('pre.code-highlight > code, pre > code').each(function(i, block) {
    if (!$(this).hasClass('codeblock')) {
      $(this).addClass('codeblock');
    }
    hljs.highlightBlock(block);
  });
});
</script>




    
  </body>
</html>

